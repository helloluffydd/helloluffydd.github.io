{"componentChunkName":"component---src-templates-post-tsx","path":"/weird-JavaScript_01/","result":{"data":{"markdownRemark":{"html":"<p>相信你看完這篇就不會想學 JavaScript 了。</p>\n<!-- more -->\n<h2 id=\"語法解析器syntax-parsers\" style=\"position:relative;\"><a href=\"#%E8%AA%9E%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8syntax-parsers\" aria-label=\"語法解析器syntax parsers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>語法解析器（Syntax Parsers）</h2>\n<hr>\n<blockquote>\n<p>A program that <strong>reads your code</strong> and <strong>determines what it does</strong> and <strong>if its grammar is valid</strong>.</p>\n</blockquote>\n<p>語法解析器，或稱「編譯器／直譯器」（Compiler／Interpreter），會將我們所寫的程式碼轉換成電腦（硬體）能夠接收的指令。</p>\n<p>在 JavaScript 中，語法解析器會一字一句的解析我們所寫的程式碼，並決定程式碼是否有效，或是語法上有沒有出錯。</p>\n<p>例如 <code class=\"language-text\">function say() {...}</code> 這段程式碼，語法解析器會逐字解析為：</p>\n<p><strong>f-u-n-c-t-i-o-n-空格-s-a-y-(-是否有代入參數-)-{-函式區塊內容-}</strong> </p>\n<p>語法解析器會對照該段程式碼與該程式語言所規範的語法結構： <code class=\"language-text\">function 名稱(參數) {函式內容}</code> ，如果都沒有語法上的錯誤，即決定這段程式碼為一個有效的<strong>函式（function）</strong>。</p>\n<p>如果語法有誤（拼錯、漏字、順序不對等等），即會出現常見的 <code class=\"language-text\">SyntaxError</code> 。</p>\n<p><strong>JavaScript 不是一種程式語言嗎？為什麼還需要 Syntax Parser 去解析成電腦才懂的語言？</strong>\n因為不是所有程式語言都是電腦懂的指令碼，就 JavaScript 而言，它是屬於高階程式語言（High-level language）的一種（其他如 C 、 Java 等等），需要經由編譯器（Compiler）將其原始碼轉換成電腦可以解讀、執行的低階機器語言，即目標語言（機器碼 Machine Code）。</p>\n<p>小結：</p>\n<ol>\n<li>Syntax Parsers 是一個中介轉譯器，協助我們（寫的程式碼）與電腦（韌體）溝通，</li>\n<li>電腦（韌體）接收到的指令，其實不完全是我們寫的程式碼，而是經過 Syntax Parsers 轉譯過的指令。</li>\n</ol>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8050c31a48fd4d751329694c26890e34/ddced/syntaxParser.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAGp165uE0gf/8QAGRAAAgMBAAAAAAAAAAAAAAAAAQMCEBES/9oACAEBAAEFAhJvZLMBZUK//8QAGhEAAgIDAAAAAAAAAAAAAAAAAAECERIxYf/aAAgBAwEBPwFzt6M+H//EABURAQEAAAAAAAAAAAAAAAAAAAAS/9oACAECAQE/AZS//8QAGxAAAgEFAAAAAAAAAAAAAAAAAAEgITEyQYH/2gAIAQEABj8CWVzuh1bh/8QAGxAAAgIDAQAAAAAAAAAAAAAAAREAIRAxQVH/2gAIAQEAAT8hPFp6E6qe9lAyBtUVjrH/2gAMAwEAAgADAAAAECfv/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAERQVH/2gAIAQMBAT8QQh0I4P/EABcRAQEBAQAAAAAAAAAAAAAAAAEAEVH/2gAIAQIBAT8QECba7f/EABwQAQEAAQUBAAAAAAAAAAAAAAERIQAQMUFhsf/aAAgBAQABPxB7VMRQS9s41eE4OdBuEnHugwhiOJDzb77f/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Syntax Parsrer是我們與電腦之間的中介溝通者（圖片源自參考資料 1.）\"\n        title=\"Syntax Parsrer是我們與電腦之間的中介溝通者（圖片源自參考資料 1.）\"\n        src=\"/static/8050c31a48fd4d751329694c26890e34/80e3c/syntaxParser.jpg\"\n        srcset=\"/static/8050c31a48fd4d751329694c26890e34/80e3c/syntaxParser.jpg 720w,\n/static/8050c31a48fd4d751329694c26890e34/ddced/syntaxParser.jpg 1100w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>Syntax Parsrer是我們與電腦之間的中介溝通者（圖片源自參考資料 1.）</p></figcaption>\n  </figure></p>\n<h2 id=\"詞彙環境lexical-environments\" style=\"position:relative;\"><a href=\"#%E8%A9%9E%E5%BD%99%E7%92%B0%E5%A2%83lexical-environments\" aria-label=\"詞彙環境lexical environments permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>詞彙環境（Lexical Environments）</h2>\n<hr>\n<blockquote>\n<p>Where something sits physically in <strong>the code you write</strong>.</p>\n</blockquote>\n<p>簡單來說，詞彙環境指的是<strong>你的（某一段） Code 寫在哪裡？附近有哪些 Code ？</strong>。</p>\n<p><strong>程式碼的位置，決定了語法解析器如何解析你所寫的程式碼</strong>，這在 JavaScript 中尤其重要，很多<strong>JavaScript 奇怪的部分</strong>就是因為 lexical 的緣故，這在我們後面提到變數環境、函式作用域與範圍鏈（Scope Chain）時就能深刻體會到箇中奧妙。</p>\n<p>有時候我們寫的程式碼執行結果與期待不符，往往就是因為寫錯 <strong>Code 的位置（lexical）</strong>。更直白地說，我們<strong>不夠熟悉程式語言（JavaScript）解析語法的邏輯和規範</strong>。</p>\n<p>譬如下面這段程式碼：</p>\n<div class=\"gatsby-code-title\">example.js</div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">;</span> <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span><span class=\"token operator\">++</span>b<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 結果會出現什麼？</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 那這個結果會出現什麼？</span>\n\n<span class=\"token comment\">// 我猜你現在心裡 OS：What the ... ?????</span></code></pre></div>\n<p>小結：</p>\n<ul>\n<li>你的（某一段） Code 寫在哪裡很重要！</li>\n<li>你的（某一段） Code 寫在哪裡很重要！！</li>\n<li>你的（某一段） Code 寫在哪裡很重要！！！</li>\n<li>可以說，學習一門程式語言，最核心技術面關鍵便是<strong>掌握該語言的語法結構</strong>。</li>\n</ul>\n<h2 id=\"執行脈絡execution-contexts\" style=\"position:relative;\"><a href=\"#%E5%9F%B7%E8%A1%8C%E8%84%88%E7%B5%A1execution-contexts\" aria-label=\"執行脈絡execution contexts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>執行脈絡（Execution Contexts）</h2>\n<hr>\n<blockquote>\n<p><strong>A wrapper</strong> to <strong>help</strong> manage <strong>the code</strong> that is <strong>running</strong>.</p>\n</blockquote>\n<p>講到脈絡（context），這個詞，<del>就得提到歷史社會學（Historical sociology）</del>，它最常被用來代指「（一個事件的）來龍去脈」：什麼先發生？什麼接著發生？發生的時候，客觀環境是怎麼樣？諸如此類，譬如「社會脈絡」、「歷史脈絡」等詞。</p>\n<p>用這樣的語義去思考，程式語言中的執行脈絡（又稱「執行環境」）指的是，<strong>正在執行的 Code 所處的脈絡（上下文）為何？前面有哪些 Code ？後面接了哪些 Code ？被什麼 Code 所包覆（wrapped）？</strong>。</p>\n<p>表面上，執行脈絡包含你所寫的、正在執行的程式碼，但，其實，<strong>它不只包含你寫的 Code</strong> ，還包含處理其他事情（do other things），因為你的 Code 事實上會經過編譯器轉換，而編譯器轉換的方式不盡然只執行你寫的 Code 。（傲嬌的編譯器？）</p>\n<p>簡單理解 JavaScript 的執行脈絡，可以舉這個例子：在函式（function）中宣告變數（Variable）。</p>\n<div class=\"gatsby-code-title\">example.js</div>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">testA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 這裡的 a 是多少？</span>\n  <span class=\"token function\">testB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> \n\n<span class=\"token keyword\">function</span> <span class=\"token function\">testB</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">200</span> <span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 這裡的 a 又是多少？</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> a <span class=\"token punctuation\">;</span>\n<span class=\"token function\">testA</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 那這裡的 a 呢？</span>\n\n<span class=\"token comment\">// 上述程式碼執行後的結果， a 值印出順序為何？</span></code></pre></div>\n<h2 id=\"結論\" style=\"position:relative;\"><a href=\"#%E7%B5%90%E8%AB%96\" aria-label=\"結論 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>結論</h2>\n<hr>\n<ul>\n<li>語法解析器：我們所寫的 JavaScript 必須經由語法解析器轉換成電腦（韌體）理解的語言，所以，語義很重要！</li>\n<li>詞彙環境：Code 寫的位置（語法結構）很重要！</li>\n<li>執行脈絡：目前執行的 Code 所處的環境／上下文是什麼？</li>\n</ul>\n<h2 id=\"參考資料\" style=\"position:relative;\"><a href=\"#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\" aria-label=\"參考資料 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>參考資料</h2>\n<hr>\n<ol>\n<li>JavaScript 全攻略：克服 JS 奇怪的部分 2-6</li>\n</ol>","excerpt":"相信你看完這篇就不會想學 JavaScript 了。","tableOfContents":"<ul>\n<li><a href=\"/weird-JavaScript_01/#%E8%AA%9E%E6%B3%95%E8%A7%A3%E6%9E%90%E5%99%A8syntax-parsers\">語法解析器（Syntax Parsers）</a></li>\n<li><a href=\"/weird-JavaScript_01/#%E8%A9%9E%E5%BD%99%E7%92%B0%E5%A2%83lexical-environments\">詞彙環境（Lexical Environments）</a></li>\n<li><a href=\"/weird-JavaScript_01/#%E5%9F%B7%E8%A1%8C%E8%84%88%E7%B5%A1execution-contexts\">執行脈絡（Execution Contexts）</a></li>\n<li><a href=\"/weird-JavaScript_01/#%E7%B5%90%E8%AB%96\">結論</a></li>\n<li><a href=\"/weird-JavaScript_01/#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\">參考資料</a></li>\n</ul>","fields":{"slug":"/weird-JavaScript_01/"},"frontmatter":{"title":"Wierd JavaScript - 01：語法解析、詞彙環境、執行脈絡","date":"2019-08-04","update":"0001-01-01","tags":["Wierd JavaScript"],"keywords":["Luffy on the Way","Luffy Chen"],"featuredImage":{"publicURL":"/static/8050c31a48fd4d751329694c26890e34/syntaxParser.JPG"}}}},"pageContext":{"slug":"/weird-JavaScript_01/","series":[{"slug":"/weird-JavaScript_01/","title":"Wierd JavaScript - 01：語法解析、詞彙環境、執行脈絡","num":1},{"slug":"/weird-JavaScript_02/","title":"Wierd JavaScript - 02：Name / Value Pair 與物件","num":2},{"slug":"/weird-JavaScript_03/","title":"Wierd JavaScript - 03：全域環境與全域物件","num":3},{"slug":"/weird-JavaScript_04/","title":"Wierd JavaScript - 04：創造、提升與 undefined","num":4},{"slug":"/weird-JavaScript_05/","title":"Wierd JavaScript - 05：單執行緒、同步執行、非同步回呼","num":5},{"slug":"/weird-JavaScript_06/","title":"Wierd JavaScript - 06：呼叫函式、執行堆疊","num":6},{"slug":"/weird-JavaScript_07/","title":"Wierd JavaScript - 07：變數環境與範圍鍊","num":7},{"slug":"/weird-JavaScript_08/","title":"Wierd JavaScript - 08：作用域、let 與區塊作用域","num":8},{"slug":"/weird-JavaScript_09/","title":"Wierd JavaScript - 09：動態型別","num":9},{"slug":"/weird-JavaScript_10/","title":"Wierd JavaScript - 10：基本型別（純值）與物件型別","num":10},{"slug":"/weird-JavaScript_11/","title":"Wierd JavaScript - 11：運算子","num":11},{"slug":"/weird-JavaScript_12/","title":"Wierd JavaScript - 12：運算子的優先性與相依性","num":12},{"slug":"/weird-JavaScript_13/","title":"Wierd JavaScript - 13：強制型轉","num":13},{"slug":"/weird-JavaScript_14/","title":"Wierd JavaScript - 14：存在與布林、條件判斷與預設值","num":14},{"slug":"/weird-JavaScript_15/","title":"Wierd JavaScript - 15：創造物件、物件實字","num":15},{"slug":"/weird-JavaScript_16/","title":"Wierd JavaScript - 16：物件的屬性、方法以及取用","num":16},{"slug":"/weird-JavaScript_17/","title":"Wierd JavaScript - 17：偽裝命名空間","num":17},{"slug":"/weird-JavaScript_18/","title":"Wierd JavaScript - 18：JSON v.s. 物件","num":18},{"slug":"/weird-JavaScript_19/","title":"Wierd JavaScript - 19：一級函式","num":19},{"slug":"/weird-JavaScript_20/","title":"Wierd JavaScript - 20：函式陳述式與函式表達式","num":20},{"slug":"/weird-JavaScript_21/","title":"Wierd JavaScript - 21：傳值 v.s. 傳參考","num":21},{"slug":"/weird-JavaScript_22/","title":"Wierd JavaScript - 22：What's this ?","num":22},{"slug":"/weird-JavaScript_23/","title":"Wierd JavaScript - 23：陣列","num":23},{"slug":"/weird-JavaScript_24/","title":"Wierd JavaScript - 24：參數（parameter v.s. arguments）","num":24},{"slug":"/weird-JavaScript_25/","title":"Wierd JavaScript - 25：重載函式","num":25},{"slug":"/weird-JavaScript_26/","title":"Wierd JavaScript - 26：語法解析器","num":26},{"slug":"/weird-JavaScript_27/","title":"Wierd JavaScript - 27：自動插入分號","num":27},{"slug":"/weird-JavaScript_28/","title":"Wierd JavaScript - 28：空格","num":28},{"slug":"/weird-JavaScript_29/","title":"Wierd JavaScript - 29：立即呼叫函式表達式（IIFEs）","num":29},{"slug":"/weird-JavaScript_30/","title":"Wierd JavaScript - 30：IIFEs 與安全程式碼","num":30},{"slug":"/weird-JavaScript_31/","title":"Wierd JavaScript - 31：閉包（1）","num":31},{"slug":"/weird-JavaScript_32/","title":"Wierd JavaScript - 32：閉包（2）","num":32},{"slug":"/weird-JavaScript_33/","title":"Wierd JavaScript - 33：函式工廠","num":33},{"slug":"/weird-JavaScript_34/","title":"Wierd JavaScript - 34：閉包與回呼","num":34},{"slug":"/weird-JavaScript_35/","title":"Wierd JavaScript - 35：call()、apply()、bind()","num":35},{"slug":"/weird-JavaScript_36/","title":"Wierd JavaScript - 36：函式程式設計（一）","num":36},{"slug":"/weird-JavaScript_37/","title":"Wierd JavaScript - 37：函式程式設計（二）","num":37},{"slug":"/weird-JavaScript_38/","title":"Wierd JavaScript - 38：古典繼承 v.s. 原型繼承","num":38},{"slug":"/weird-JavaScript_39/","title":"Wierd JavaScript - 39：原型與原型鍊","num":39},{"slug":"/weird-JavaScript_40/","title":"Wierd JavaScript - 40：所有東西都是物件（或純值）","num":40}],"lastmod":"2019-08-04"}},"staticQueryHashes":["2027115977"]}
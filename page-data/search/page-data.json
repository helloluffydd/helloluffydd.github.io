{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n欸！ JavaScript 裡面的所有東西都是物件！\n\n<!-- more -->\n\n## 物件、陣列與函式的原型\n\n上篇我們談到，所有物件，包括物件、陣列以及函式，都具有原型。\n\n我們可以用這段程式碼來驗證：\n\n```javascript\nvar a = {} ;\nvar b = [] ;\nvar c = function(){} ;\n\nconsole.log(a.__proto__) ; \nconsole.log(b.__proto__) ; \nconsole.log(c.__proto__) ; \n```\n\n執行上面這段程式碼，得到結果如下圖：\n\n![原型](./prototypeAll.JPG)\n\n我們分別來看一下物件 `a` 、陣列 `b` 以及函式 `c` 的原型。\n\n### 物件的原型\n\n<br>\n\n物件 `a` 的原型是一個**物件**，該物件包含一些我們平常在物件中可以取用的方法，如下圖：\n\n![物件的原型](./objProto.JPG)\n\n以 `hasOwnProperty()` 為例：\n\n```javascript\nvar a = {\n  firstname: 'Hai',\n  lastname: 'An'\n}\n\na.hasOwnProperty('firstname') ; // true \n```\n\n在任何一個物件中，我們可以取用 `hasOwnProperty()` 來檢測該**物件本身**是否有某一個屬性，因為所有物件的原型都包含了 `hasOwnProperty()` 這個方法。\n\n也就是說，所有物件都有原型，指向一個**擁有 JS 處理物件方法的物件**。\n\n我們可以發現，物件 `a` 的原型裡面並沒有 `__proto__` 這個屬性，表示該原型已經是原型鍊的最底層，即**基本物件（Base Object）**。\n\n### 陣列物件的原型\n\n---\n\n我們說過，陣列也屬於物件的一種，可稱之為陣列物件。\n\n陣列 `b` 的原型是一種**陣列物件**，該物件也包含一些我們平常在陣列中可以取用的方法，如 `push()` 、 `filter()` 、 `forEach()` 等等：\n\n![陣列物件的原型](./arrProto.JPG)\n\n簡單來說，所有陣列都有原型，指向一個**擁有 JS 處理陣列方法的物件**。\n\n值得注意的是，陣列 `b` 的原型 `b.__proto__` 還有 `__proto__` 這個屬性，表示 `b.__proto__` 還能向上找到它自己的原型 `b.__proto__.__proto__` ，該原型是一個基本物件，即原型鍊最底層的物件。\n\n### 函式物件的原型\n\n根據一級函式的特性，函式也屬於物件的一種，我們稱為函式物件。\n\n函式 `c` 的原型是**函式物件**，該物件同樣包含一些我們平常在函式中可以取用的方法，如 `call()` 、 `apply()` 、 `bind()` 等等：\n\n![函式物件的原型](./funProto.JPG)\n\n簡單來說，所有函式都有原型，指向一個**擁有 JS 處理函式方法的物件**。\n\n與陣列物件相仿，函式 `c` 的原型 `c.__proto__` 仍有 `__proto__` 這個屬性，表示 `c.__proto__` 還能向上找到它自己的原型 `c.__proto__.__proto__` ，該原型是一個**基本物件**，即原型鍊最底層的物件。\n\n<hr>\n\n## 結論\n\n下面這張圖檢驗了 `c.__proto__.__proto__` ，結果與 `a.__proto__` 和 `b.__proto__.__proto__` 相同 ：\n\n![函式物件的原型鍊底層](./funProtoBase.JPG)\n\n我們用邏輯判斷來檢驗這三者是否相同：\n\n```javascript\nvar a = {} ;\nvar b = [] ;\nvar c = function(){} ;\n\nconsole.log(a.__proto__ === b.__proto__.__proto__) ; // true\nconsole.log(a.__proto__ === c.__proto__.__proto__) ; // true\nconsole.log(b.__proto__.__proto__ === c.__proto__.__proto__) ; // true  \n```\n\n我們發現，物件、陣列與函式的原型鍊最終會指向同一個**基本物件！**\n\n總而言之，**除了刻意設定原型，如 `setPrototypeOf` 、 `Object.create()` 、 `new` 等情況以外**，JS 引擎會自動幫我們設定物件、陣列與函式的原型，該**原型包含一些 JS 內建處理資料的方法**。\n\n而無論是哪一種資料型別，資料的**原型鍊終點都會指向基本物件**！\n\n咦？你問基本物件的原型是什麼？\n```javascript\nvar a = {} ;\nconsole.log(a.__proto__.__proto__) ; // null\n```\n沒錯，就是 `null` ！\n\n那你知道 `null` 屬於什麼資料型態嗎？\n```javascript\ntypeof null ; // object \n```\n欸！就說了， **JavaScript 裡面的所有東西都是物件！**\n\n<!-- 最後，我們可以畫出這張物件、陣列與函式的原型鍊結構： -->\n\n<!-- ![物件、陣列與函式的原型鍊結構](./protoStruct.JPG) -->\n\n<hr>\n\n## 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 5-54\n\n\n\n","excerpt":"欸！ JavaScript 裡面的所有東西都是物件！","fields":{"slug":"/weird-JavaScript_40/"},"frontmatter":{"date":"2019-09-09","title":"Wierd JavaScript 40：所有東西都是物件（或純值）","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n來瞭解原型吧！　　\n\n<!-- more -->\n\n上篇我們說過 JavaScript 採用**原型繼承**的方式，將所有物件連結起來。所以，什麼是**原型（Prototype）**？\n\n### 原型（Prototype）\n\n在 JavaScript 中，所有物件，包括函式、陣列，都具有**原型屬性 `__proto__`**，原型屬性會參考到另外一個物件，就是所謂的**原型物件**。\n\n同樣的，原型物件本身也擁有原型屬性，會參考到另外一個物件，即該原型物件的原型物件。\n\n依此類推，每個物件都具備原型物件，我們能藉由取用運算子 `.` 以及原型屬性 `__proto__` 去存取。\n\n透過原型屬性串起來的物件，看起來就像由數個物件串起來的鍊子，我們稱之為**原型鍊（Prototype Chain）**。\n\n下面這張圖概略解釋了原型機制：\n\n![範圍鍊（圖片源自參考資料 1.）](./prototypeChain.JPG)\n\n<br>\n\n假設有一個物件 `Obj` ，我想要存取屬性 `Prop3` ，但由於 `Obj` 本身並沒有這個屬性，所以 JS 引擎會幫我**向原型鍊尋找**，找到物件 `Obj` 原型的原型 `proto` 並取用到屬性 `Prop3` 。\n\nJS 引擎向原型鍊尋找的過程是隱藏的，也就是說，我只要 `Obj.Prop3` ，就能取用到 `Prop3` ，而不需要特地 `Obj.__proto__.proto__.Prop3` ，\n\n除此之外，假設有另外一個物件 `Obj2` ，它可以和物件 `Obj` **共享**同一個原型物件，並取用原型物件具備的屬性或方法，如下圖 `Prop2`。  \n\n![範圍鍊（圖片源自參考資料 1.）](./prototypeChain2.JPG)\n\n<br>\n\n先前，我們也提過**範圍鍊（Scope Chain）**，指的是**函式執行**過程中，當執行環境沒有可用的變數，JS 引擎向外部詞彙環境尋找可取用的變數的過程。\n\n這裡提到的**原型鍊（Prototype Chain）**，指的是**物件取用**過程中，物件本身沒有可用的屬性或方法，JS 引擎向原型物件尋找可用的屬性或方法的過程。\n\n接著，我們來透過一些程式範例理解原型：\n\n```javascript\nvar person = {\n  firstname: 'Default',\n  lastname: 'Default',\n  getFullName: function(){\n    return this.firstname + ' ' + this.lastname ;\n  }\n}\n\nvar Hai = {\n  firstname: 'Hai',\n  lastname: 'An',\n}\n\n// Don't do this EVER !! \n// 為了展示方便，我們得透過 __proto__ 設定 Hai 的原型，但實務上我們不會這樣做！\nHai.__proto__ = person ;\n\nconsole.log(Hai.getFullName());\nconsole.log(Hai.firstname);\n```\n\n需要特別注意的是，物件 `Hai` 呼叫方法 `getFullName` 後，JS 引擎會創造其函式執行環境，其中的變數 `this` 會代指呼叫 `getFullName` 的物件，即 `Hai` ，而非 `person` 。\n\n同樣的程式碼，我們加上物件 `Jane` ：\n\n```javascript\nvar person = {\n  firstname: 'Default',\n  lastname: 'Default',\n  getFullName: function(){\n    return this.firstname + ' ' + this.lastname ;\n  }\n}\n\nvar Hai = {\n  firstname: 'Hai',\n  lastname: 'An',\n}\n\nvar Jane = {\n  firstname: 'Jane',\n}\n\n// Don't do this EVER !! \n// 為了展示方便，我們得透過 __proto__ 設定 Hai 的原型，但實務上我們不會這樣做！\nHai.__proto__ = person ;\nJane.__proto__ = person ;\n\nconsole.log(Jane.getFullName());\nconsole.log(Hai.lastname);\nconsole.log(Jane.lastname);\n```\n\n比較 `console.log(Hai.lastname);` 與 `console.log(Jane.lastname);` 的差異，可知，如果物件本身已有可用的屬性或方法，JS 就不會向原型鍊尋找。當 JS 引擎在原型鍊中找到可用的屬性或方法，便立即停止搜尋，並回傳該值。\n\n<hr>\n\n### 結論\n* 在 JavaScript 中，所有物件，包括函式、陣列，都具有原型屬性 `__proto__`，原型屬性會參考到另外一個物件。\n* 透過原型屬性串起來的物件，我們稱之為原型鍊（Prototype Chain）。\n* 原型鍊指的是物件取用過程中，物件本身沒有可用的屬性或方法，因此 JS 引擎向原型物件尋找可用的屬性或方法的過程。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 5-54\n","excerpt":"來瞭解原型吧！","fields":{"slug":"/weird-JavaScript_39/"},"frontmatter":{"date":"2019-09-08","title":"Wierd JavaScript 39：原型與原型鍊","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n與其他程式語言不同，JavaScript 採用原型繼承的方式，將所有物件串聯起來！\n\n<!-- more -->\n\n### 物件導向（Object Oriented）\n\nJavaScript 是屬於**物件導向**的程式語言。\n\n物件導向，指的是，在 JavaScript 中，**物件**被視為程式組成的基本單元，而且物件之間彼此都會透過**繼承**的方式互相連結，產生關係，以便資料互相傳遞、取用。\n\n<hr>\n\n### 繼承（Inheritance）\n\n{% colorquote info %}\nOne object gets access to the properties and methods of another object.\n{% endcolorquote %}\n\n繼承，指的是**一個物件取用另外一個物件的屬性或方法**。\n\n假設我有兩個物件 `ObjA` 與 `ObjB` ， `ObjA` 繼承了 `ObjB` ，那麼，我就能在 `ObjA` 中取用 `ObjB` 的屬性與方法。\n\n也就是說，當我們創造一個物件時，JS 引擎其實已經將它與另外一個物件**連起來**，而這個連起來的機制，就是所謂的繼承。\n\n而繼承的方式，主要分為**古典繼承**與**原型繼承**兩類。\n\n<hr>\n\n### 古典繼承（Classical Inheritance）\n\n古典繼承是當代非常主流而熱門的繼承方式， **Java** 、 **C#** 等程式語言都是採用古典繼承的設計機制。\n\n古典繼承的特點在於相當口語化（Verbose），而且有非常多的方法可以使用，譬如：\n\n* Friend（夥伴）\n* Protected（保護）\n* Private（私用）\n* Interface（介面）\n\n但古典繼承的弱勢在於，必須瞭解上述規範的方法，才能輕易使用它。\n\n除此之外，古典繼承採用樹狀結構的設計模式，當繼承物件數量增加時，很容易將物件集合成一個大熔爐，讓人搞不清楚內部物件詳細的連結方式。古典繼承好比一棟設計複雜的房子，當你想要換燈泡的時候，卻發現馬桶開始沖水，就好像，修改了 A 物件，卻非預期地影響了 B 物件。\n\n<hr>\n\n### 原型繼承（Prototypal Inheritance）\n\n相較於古典繼承，原型繼承較簡單易懂（Easy to understand），且具備彈性（Flexible）、可延展（Extensible）等優勢。\n\n而 **JavaScript** 正是透過**原型繼承**的方式，將所有物件都串聯起來。\n\n往後幾篇會介紹 JS 的原型以及繼承機制。\n\n<hr>\n\n### 結論\n* 繼承，指的是一個物件取用另外一個物件的屬性或方法。\n* JavaScript 屬於物件導向的程式語言，它透過原型繼承的方式，將所有物件都串聯起來。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 5-53\n2. [Wiki：物件導向程式設計](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)\n","excerpt":"與其他程式語言不同，JavaScript 採用原型繼承的方式，將所有物件串聯起來！","fields":{"slug":"/weird-JavaScript_38/"},"frontmatter":{"date":"2019-09-07","title":"Wierd JavaScript 38：古典繼承 v.s. 原型繼承","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n透過資源庫培養函式程式設計的思維！\n\n<!-- more -->\n\n### 開源教育\n\n**Underscore** 就像 jQuery 一樣，是一個知名的 JavaScript **資源庫（Library）**，內含許多處理陣列、物件以及函式的語法。\n\n類似功能的資源庫還有後起之秀 **Lodash** ，它也包括處理陣列、物件以及陣列的語法，且效率更好，速度更快，逐漸取代 Underscore.js 成為主流。\n\n相關連結：\n* [Underscore](https://underscorejs.org/#)\n* [Lodash](https://lodash.com/)\n\n\n課程講師鼓勵我們透過閱讀、解析這些框架（Frame）、資源庫的原始碼，去深入理解函式程式設計的方法與原理，這個過程符合**開源教育（Open Source Education）**的精神。\n\n我們可以點擊上方連結，到 Underscore 的官方網站，下載 Development（擁有註解） 的版本，並在 Visual Studio 中打開 `underscore.js` ，從中檢視原始碼撰寫的設計原理。\n\n<hr>\n\n### Underscore.js\n\n檢視 `underscore.js` 的原始碼，我們會發現所有程式碼都被包在一個 IIFE 裡面，保證我們載入這個 Library 後，其內容不會與我們撰寫的程式碼產生衝突。\n\n載入 `underscore.js` ：\n\n```html\n<html>\n  <head></head>\n  <body>\n    ...\n    <script scr=\"underscore.js\"></script>\n    <script scr=\"app.js\"></script> // 我們自己撰寫的 JavaScript\n  </body>\n</html>\n```\n\n使用 `underscore.js` 的語法：\n\n```javascript \nvar arr1 = _.map([1, 2, 3, 4, 5], function(item){\n  return item * item ;\n})\n\nvar arr2 = _.filter([1, 2, 3, 4, 5, 6], function(item){\n  return item % 2 === 0 ;\n})\n\nconsole.log(arr1) ;\nconsole.log(arr2) ;\n```\n\n<hr>\n\n### 結論\n* 找各式各樣的 JavaScript 框架或資源庫（Library）來玩，閱讀、理解它們的原始碼，培養程式設計的經驗與感覺。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-52\n","excerpt":"透過資源庫培養函式程式設計的思維！","fields":{"slug":"/weird-JavaScript_37/"},"frontmatter":{"date":"2019-09-05","title":"Wierd JavaScript 37：函式程式設計（二）","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n邁向進階 JavaScript ：函式程式設計（Functional Programming）\n\n<!-- more -->\n\n### 函式程式設計（Functional Programming）\n\n我們知道，一級函式是 JavaScript 的重點特色，讓我們能夠將函式當作參數傳入另一個函式，而這樣的特色，讓 JavaScript 得以函式為核心，去設計各式各樣的程式語法，達到不同的效果與目的，而這個思考與實作的過程就是所謂的**函式程式設計（Functional Programming）**。\n\n在課程中，講師以範例來說明：\n\n```javascript\nvar arr1 = [1, 2, 3] ;\nvar arr2 = [] ;\n\nfor (var i = 0 ; i < arr1.length ; i++){\n  arr2.push(arr1[i] * 2);\n}\n\nconsole.log(arr2) ;\n```\n\n上面這個範例中，我們想將陣列 `arr1` 中的每一個數值乘以 `2` 以後傳入 `arr2` 中。\n\n身為工程師，我們可以思考如何優化這段程式碼？如何讓程式碼更為簡潔？更為彈性？\n\n其實，我們可以善用**函式**讓程式碼更為**彈性**，只要改動函式的參數或程式屬性，就可以**減少許多重複的工作**，這就是函式程式設計的基本思維。\n\n我們試著改寫上面這段程式碼，如下：\n\n```javascript\nvar arr1 = [1, 2, 3] ;\n\nfunction mapForEach(array, func) {\n  var newArr = [] ;\n\n  for (var i = 0 ; i < array.length ; i++){\n    newArr.push(func(array[i]));\n  }\n\n  return newArr ;\n}\n\nvar arr2 = mapForEach(arr1, function(item){\n  return item * 2 ;\n})\n\nconsole.log(arr2);\n```\n\n我們可以宣告一個函式 `mapForEach` ，並規定傳入兩個參數，第一個 `array` 是**我們想要處理的陣列**，第二個 `func` 是**我們想要針對陣列中每一個值進行的運算方式**。 \n\n現在，我們只要將 `arr1` 與 `function(item){return item * 2　;}` 分別當作參數 `array` 與 `func` 傳入函式 `mapForEach` 中，執行回傳的結果再賦值給 `arr2` ，這樣的方式與改寫前的範例程式碼，執行的結果是相同的。\n\n不同的地方在哪？\n\n不同的地方在於，我們把原本程式碼的執行任務：「將陣列 `arr1` 中的每一個數值乘以 `2` 以後傳入 `arr2` 中」這一整件事情**包裝**成函式 `mapForEach` ，它的功能變成：「將陣列 `array` 中的每一個數值經過 `func` 運算以後 `return`」。\n\n如此一來，我們**可以自定義**傳入的參數 `array` 和 `func` ，讓函式 `mapForEach` 的彈性與複用性變高了！\n\n譬如，我想要判斷陣列中的數值是否大於 `1` ，我只要改變傳入 `func` 的參數：\n\n```javascript\nvar arr1 = [1, 2, 3] ;\n\nfunction mapForEach(array, func) {\n  var newArr = [] ;\n\n  for (var i = 0 ; i < array.length ; i++){\n    newArr.push(func(array[i]));\n  }\n\n  return newArr ;\n}\n\nvar arr2 = mapForEach(arr1, function(item){\n  return item > 1 ;\n})\n\nconsole.log(arr2);\n```\n\n當然，我們也可以把函式存進一個變數後，將該變數當作參數傳入另一個函式，甚至先做一點處理。\n\n課程中，講師利用 `bind()` 方法，改寫上面這段程式碼：\n\n```javascript\nvar arr1 = [1, 2, 3] ;\n\nfunction mapForEach(array, func) {\n  var newArr = [] ;\n\n  for (var i = 0 ; i < array.length ; i++){\n    newArr.push(func(array[i]));\n  }\n\n  return newArr ;\n}\n\nvar checkPastLimit = function(limiter, item){\n  return itme > limiter ;\n}\n\nvar arr2 = mapForEach(arr1, checkPastLimit.bind(this, 2))\n\nconsole.log(arr2);\n```\n\n透過 `bind()` ，我們可以自由綁定參數 `limiter` 的值。\n\n如果不使用 `bind()` 呢？有沒有辦法改寫 `checkPastLimit.bind(this, 2)` ，設計一個函式，只要傳入 `limiter` 的值，還能達到同樣的結果？\n\n先別急著往下看，請試著動手寫寫看！\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n```javascript\nvar arr1 = [1, 2, 3] ;\n\nfunction mapForEach(array, func) {\n  var newArr = [] ;\n\n  for (var i = 0 ; i < array.length ; i++){\n    newArr.push(func(array[i]));\n  }\n\n  return newArr ;\n}\n\n// 我自己寫的錯誤答案： \n// var setLimiter = function(limiter) {\n// 我以為 limiter 會被當作參數傳入（但並不會，因為這裡不是執行函式）\n//   return function(limiter, item){\n//     return item > limiter ;\n//   };\n\n// 正確解答：\nvar setLimiter = function(limiter) {\n  // 創造函式物件\n  return function(limiter, item){\n    return item > limiter ;\n  }.bind(this, limiter);\n}\n\nvar arr2 = mapForEach(arr1, setLimiter(2))\n\nconsole.log(arr2);\n```\n\n要特別注意的是，函式 `setLimiter` 中的 `return function(limiter, item)` ，其意義為**表示式**，意思是**創造函式物件** `function(limiter, item)` 後並回傳，並非執行函式 `function(limiter, item)` 。\n\n所以，函式 `setLimiter` 傳入的參數 `limiter` 並不會作為參數傳入函式 `function(limiter, item)` ，還是要利用 `bind()` 綁定 `limiter` 的值，此時， `limiter` 會根據作用域找到函式 `setLimiter` 傳進來的參數 `limiter` 並取用。\n\n這個概念在我自己嘗試解答的時候也混淆了，分清楚**創造函式**與**執行函式**，真的很重要！\n\n最後，講師也提醒我們，在設計函式程式時，**盡量不要改變（Mutate）原始的資料（Data）**，也就是說，**注意傳值與物件傳參考的特性**，在複製資料時，以**深拷貝**或**創造新的值（物件）**來傳遞資料，如 `[].push()` 、 `Object.assign({}, obj)` 等方法。\n\n動手寫吧！將你的任務包裝成一個一個的函式，設計屬於你的 JavaScript ！\n\n<hr>\n\n### 結論\n* 函式程式設計的思維是將任務拆分、打包成一個一個的函式（與變數），透過傳入參數的方式，減少重複撰寫程式碼，提升函式的彈性與複用性。\n* 釐清創造函式與執行函式的時機，有利於函式程式設計，瞭解函式作用域、範圍鍊與閉包的原理。\n* 設計函式程式時，盡量不要改變（Mutate）原始的資料（Data），注意物件傳參考的特性，以深拷貝（請見參考資料文章）或創造新物件的方式來傳遞資料。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-51\n2. [[Javascript] 關於 JS 中的淺拷貝和深拷貝](https://larry850806.github.io/2016/09/20/shallow-vs-deep-copy/)\n","excerpt":"邁向進階 JavaScript ：函式程式設計（Functional Programming）","fields":{"slug":"/weird-JavaScript_36/"},"frontmatter":{"date":"2019-09-04","title":"Wierd JavaScript 36：函式程式設計（一）","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\ncall() 、 apply() 、 bind() 都屬於函式的方法，可以用來改變函式中 this 代指的對象。\n\n<!-- more -->\n\n### call()\n\n`call()` 用來**呼叫**函式，和我們平常使用 `()` 來呼叫函式是一樣的。\n\n```javascript\nvar logPerson = function() {\n  console.log(this) ;\n  console.log('Call function log.') ;\n} ;\n\nlogPerson.call() ;\n```\n\n當然， `call()` 不可能這麼無聊，它具有綁定 `this` 的功能。我們可以在 `()` 傳入一個參數，指定函式執行時 `this` 代表的對象。\n\n```javascript\nvar person = {\n  firstname: 'John',\n  lastname: 'Doe',\n  age: 28,\n  personSay: function(){\n    console.log('Hello! I am ' + this.firstname + ' ' + this.lastname) ;\n  }\n} ;\n\nvar logPerson = function() {\n  console.log(this) ;\n  this.personSay() ;\n  console.log(this.age) ;\n} ;\n\nlogPerson.call(person) ;\n```\n\n如果函式本身可以代入參數，可以在指定 `this` 的參數後方，也就是由第二個參數開始依序傳入。\n\n```javascript\nvar person = {\n  firstname: 'John',\n  lastname: 'Doe'\n} ;\n\nvar logPerson = function(para1, para2) {\n  console.log(this) ;\n  console.log(this.firstname + ' ' + this.lastname + ' likes ' + para1 + ' and ' + para2) ;\n} ;\n\nlogPerson.call(person, 'writing', 'coding') ;\n```\n\n總結 `call()` 方法：\n\n`Function.call(thisPara, para1, para2, ...)`\n\n* `Function`：所欲**呼叫**的函式\n* `thisPara` ：指定 `this` 的參數（通常是一個物件）\n* `para1` 、 `para2` 執行函式的參數\n\n<hr>\n\n### apply()\n\n`apply()` 和 `call()` 的功能幾乎相同，能夠**呼叫**函式，第一個參數傳入指定 `this` 代指的對象，唯一的差別在於第二個參數只能傳入**陣列**。\n\n```javascript\nvar person = {\n  firstname: 'John',\n  lastname: 'Doe'\n} ;\n\nvar logPerson = function(para1, para2) {\n  console.log(this) ;\n  console.log(this.firstname + ' ' + this.lastname + ' likes ' + para1 + ' and ' + para2) ;\n}\n\nlogPerson.apply(person, ['writing', 'coding']) ;\n```\n\n`call()` 和 `apply()` 的功用都是**呼叫**函式，可以搭配 IIFEs 一起服用：\n\n```javascript\nvar person = {\n  firstname: 'John',\n  lastname: 'Doe'\n} ;\n\n(function(para1, para2) {\n  console.log(this) ;\n  console.log(this.firstname + ' ' + this.lastname + ' likes ' + para1 + ' and ' + para2) ;\n}).call(person, 'writing', 'coding') ;\n\n(function(para1, para2) {\n  console.log(this) ;\n  console.log(this.firstname + ' ' + this.lastname + ' likes ' + para1 + ' and ' + para2) ;\n}).apply(person, ['writing', 'coding']) ;\n```\n\n總結 `apply()` 方法：\n\n`Function.apply(thisPara, [arrayPara])`\n\n* `Function` ：所欲**呼叫**的函式\n* `thisPara` ：指定 `this` 的參數（通常是一個物件）\n* `arrayPara`：執行函式的參數（必須為一個陣列）\n\n<hr>\n\n### bind()\n\n`bind()` 不會執行函式，而是**複製（拷貝）**函式，第一個參數傳入綁定 `this` 代指的對象。 `bind()` 結果通常會賦值給另一個變數（表達式）。\n\n```javascript\nvar John = {\n  firstname: 'John',\n  lastname: 'Doe'\n} ;\n\nvar Hai = {\n  firstname: 'Hai',\n  lastname: 'An'\n} ;\n\nvar logPerson = function(para1, para2) {\n  console.log(this) ;\n  console.log('Hello! I am ' + this.firstname + ' ' + this.lastname) ;\n}\n\nvar logJohn = logPerson.bind(John) ;\nvar logFei  = logPerson.bind(Fei) ;\n\nlogJohn() ;\nlogFei() ;\n```\n\n`bind()` 第二個參數以後傳入的值會逐一**綁定**相應的函式參數。\n\n```javascript\nfunction multiply(a, b) {\n  return a * b ;\n}\n\nvar multipleBySeven = multiply.bind(this, 7) ; // a = 7\n\n// a 綁定為 7 ，往後傳入參數由 b 開始代入。\nmultipleBySeven(9)  ; // b = 9\nmultipleBySeven(12) ; // b = 12 \n\nvar  return30 = multiply.bind(this, 5, 6) ;\n\n// a = 5 ; b = 6\nreturn30() ;\n```\n\n總結 `bind()` 方法：\n\n`Function.bind(thisPara, para1, para2, ...)`\n\n* `Function` ：所欲**拷貝**的函式\n* `thisPara` ：指定 `this` 的參數（通常是一個物件）\n* `arrayPara`：綁定函式的參數（綁定後無法更改）\n\n<hr>\n\n### 結論\n* `call()` 、 `apply()` 、 `bind()` 請看各小節總結，或參考[CodePen 範例](https://codepen.io/luffy-chen/pen/yLNJgEB?editors=0011)。\n* 若不想指定 `this` 變數，可以傳入 `this` 變數本身，如 `bind()` 中 `multiply(a, b)` 一例。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-50\n2. [MDN：Function.prototype.call](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/call)\n3. [MDN：Function.prototype.apply](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n4. [MDN：Function.prototype.bind](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\n\n","excerpt":"call() 、 apply() 、 bind() 都屬於函式的方法，可以用來改變函式中 this 代指的對象。","fields":{"slug":"/weird-JavaScript_35/"},"frontmatter":{"date":"2019-08-31","title":"Wierd JavaScript 35：call()、apply()、bind()","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n如果你曾經使用過 jQuery 、 `setTimeout` 等 Callback Function，其實你已經使用過閉包的概念了。\n\n<!-- more -->\n\n### 閉包與回呼\n\n以 `setTimeout` 這段程式碼作為範例：\n\n```javascript\nfunction sayHiLater(){\n  var greeting = 'Hi!' ;\n\n  setTimeout(function(){\n    console.log(greeting) ;\n  }, 3000) \n\n}\n\nsayHiLater() ;\n```\n\n這段程式碼的執行結果為 **「3 秒鐘後印出字串 Hi!」**。\n\n你有想過為什麼 3 秒後，回呼函式 `function(){console.log(greeting) ;}` ，為什麼能夠取用到外部詞彙環境的 `greeting` 嗎？明明函式 `sayHiLater()` 執行環境早就已經消滅。\n\n這是因為閉包的機制會將 `greeting` 的值 `'Hi!'` 儲存在函式 `sayHiLater` 專屬的記憶體中，即便執行環境消滅、執行堆疊消失後，回呼函式在詞彙環境中仍然能夠取用到自由變數 `greeting` 的值 `'Hi!'` 。\n\n我們在很遙遠的 05 篇中稍微提過**回呼（Callback）**這個概念，當時和**非同步**的概念綁在一起講。而這裡回呼函式 `function(){console.log(greeting) ;}` 同樣是**非同步回呼函式**，指的是**非同步事件中，當執行堆疊為空以後，檢視事件佇列，回頭執行的函式**。\n\n而 `function(){console.log(greeting) ;}` 之所以匿名，是因為用了**一級函式**的概念，直接創造函式並丟入 `setTimeout` 中。\n\n所以，仔細檢視這段程式碼的執行流程，應是這樣子的：\n\n1. JS 引擎建立全域執行環境、 `window` 和 `this` 。\n2. Creation & Hoisting : funciton `sayHiLater` 。\n3. `sayHiLater()`，建立函式 `sayHiLater` 的函式執行環境，並執行程式內容。\n4. `var greeting = 'Hi!'` ，宣告區域變數 `greeting` ，賦值為 `'Hi!'` 。\n5. `setTimeout(function(){console.log(greeting)}, 3000)`，**創造**匿名（非同步回呼）函式 `function(){console.log(greeting)` ，並將 `setTimeout` 放進**事件佇列**，等到**執行堆疊為空**時再執行。 \n6. 函式 `sayHiLater` 的程式內容結束，消滅其函式執行環境（但其記憶體空間不會被消滅）。\n7. 全域執行環境結束，執行堆疊為空，檢視事件佇列裡的非同步事件。\n8. 執行 `setTimeout` ，倒數 3 秒（3000 豪秒），計時開始。\n9. 3 秒後，倒數完畢，執行回呼函式 `function(){console.log(greeting)` ，印出字串 `Hi!`。\n\n<hr>\n\n### 回呼函式（Callback Function）\n\n{% colorquote warning %}\nA function you give to another function, to be run when the other function is finished.\nThe function you called(invoked), 'calls back' by calling the function you gave it when finished.\n{% endcolorquote %}\n\n理解回呼函式，可以舉 A 函式與 B 函式來說明：我們在 A 函式中創造 B 函式，接著執行 A 函式，等到 A 函式執行結束後，才回頭呼叫 B 函式，此時 B 函式就是所謂的回呼函式。\n\n簡言之，**回頭呼叫的函式，即回呼函式**（其所在的外部執行環境可能已經消滅）。\n\n回呼函式也可以想成：**將 B 函式當作 A 函式的參數傳入，並在 A 函式中呼叫 B 函式**。\n\n從非同步事件或 DOM 監聽事件的角度來看，回呼函式也是指**那些滿足特定條件才會被動觸發的函式**，如上例 `setTimeout` 或 Click 事件。\n\n課程中，講師用下面這個例子來解釋回呼函式：\n\n```javascript\nfunction tellMeWhenDone(callback){\n\n  console.log('Function tellMeWhenDone is done!') ;\n\n  callback() ; // 執行回呼函式\n}\n\n// 創造一個匿名函式作為參數傳入函式 tellMeWhenDone\ntellMeWhenDone(function(){\n  console.log('Callback function is done!') ;\n})\n```\n\n稍加改寫講師舉的例子，想一想，下面的回呼函式會印出哪一個名字？\n\n```javascript\nvar name = 'Fei' ;\n\nfunction tellMeWhenDone(callback){\n  var name = 'Bai' ;\n  console.log('Function tellMeWhenDone is done!') ;\n\n  callback() ; \n}\n\ntellMeWhenDone(function(){\n  console.log(name) ;\n})\n```\n\n<hr>\n\n### 結論\n* 回呼函式，即回頭呼叫執行的函式（其所在的外部執行環境可能已經消滅）。\n* 回呼函式，也可以想成：將 B 函式當作 A 函式的參數傳入，並在 A 函式中呼叫 B 函式，則 B 函式為回呼函式。\n* 回呼函式亦指那些滿足特定條件才會被動觸發的函式。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-49\n2. [重新認識 JavaScript: Day 18 Callback Function 與 IIFE](https://ithelp.ithome.com.tw/articles/10192739)\n\n","excerpt":"如果你曾經使用過 jQuery 、  等 Callback Function，其實你已經使用過閉包的概念了。","fields":{"slug":"/weird-JavaScript_34/"},"frontmatter":{"date":"2019-08-29","title":"Wierd JavaScript 34：閉包與回呼","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n透過閉包的原理，搭建一座座函式工廠吧！\n\n<!-- more -->\n\n### 函式工廠（Function Factory）\n\n現在，我們已經瞭解閉包的概念，那麼，在什麼樣的情況下，我們會使用閉包？\n\n再重新檢視閉包的原理：利用**函式執行環境**，創造一個**專屬的封閉空間（記憶體空間）**，**包住可供取用的變數**。\n\n我們可以試著從閉包原理的特色去推想使用情境：\n\n1. 避免污染全域變數\n2. 製作客製化的函式\n\n函式工廠，指的就是利用閉包，來協助我們製作函式化的函式，提升程式碼的編撰彈性。\n\n什麼意思？以下面這段程式碼為例：\n\n```javascript\nvar greetEnglish = makeGreeting('en') ;\nvar greetSpanish = makeGreeting('es') ;\n\nfunction makeGreeting(language){\n  \n  return function(firstname, lastname){\n    \n    if(language === 'en'){\n      console.log('Hello! ' + firstname + ' ' + lastname) ;\n    }\n\n    if(language === 'es'){\n      console.log('Hola! ' + firstname + ' ' + lastname) ;\n    }\n  }\n}\n\ngreetEnglish('Fie', 'Lu') ;\ngreetSpanish('Fei', 'Lu') ;\n```\n\n看懂了嗎？我們可以利用函式 `makeGreeting(language)` 來客製化不同語系回應的函式，只要傳入我們想要得到的語系參數 `language` 即可，有別於過去，我們還要針對不同語系一個一個宣告相對應的函式，大幅減少我們撰寫重複程式碼的時間。\n\n在這裡，函式 `makeGreeting(language)` 就像一座**工廠**，利用**其函式執行環境**，創造一個**專屬的封閉空間（記憶體空間）**，**包住可供取用的變數**（也就是參數 `language` ），並依據條件回傳不同的函式，而有不同的執行結果。\n\n而之所以可以這樣做，這是因為 `makeGreeting('en')` 與 `makeGreeting('es')` 執行後，各自創造了自己的函式執行環境，也各自擁有屬於自己的記憶體空間，以儲存參數 `language` 的值 `en` 和 `es` ，讓 `return` 的 `function(firstname, lastname)` 能夠依照範圍鍊向外部詞彙環境參考 `language` 的值，根據 `if` 判斷條件的差異，印出不同語系的招呼語：`'Hello!'` 或是 `'Hola!'`。\n\n在課程中，講師用這張圖來說明此例函式工廠的閉包原理：\n\n![利用函式作為工廠，依據計算或判斷創造另一個函式。（圖片源自參考資料 1.）](./functionFactory.JPG)\n\n<hr>\n\n### 結論\n* 閉包的原理：利用函式執行環境，創造一個專屬的封閉空間（記憶體空間），包住可供取用的變數。\n* 函式工廠指的就是利用閉包原理，把一個函式看成一個工廠，依據計算或變數判斷創造另一個函式，回傳供我們取用。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-48\n\n\n\n","excerpt":"透過閉包的原理，搭建一座座函式工廠吧！","fields":{"slug":"/weird-JavaScript_33/"},"frontmatter":{"date":"2019-08-27","title":"Wierd JavaScript 33：函式工廠","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n這題沒答對，你敢說你懂閉包？\n\n<!-- more -->\n\n### 閉包概念的程式碼範例\n\n請看下面這段程式碼，想一想這段程式碼在做什麼？\n\n你認為 `fs[0]()` 、 `fs[1]()` 、 `fs[2]()` 執行後，分別會印出什麼數字？\n\n請將答案紀錄在一張白紙上，再複製貼上這段程式碼至瀏覽器中，檢驗是否正確。\n\n```javascript\nvar fs = buildFunctions() ;\n\nfunction buildFunctions(){\n  var arr = [] ;\n\n  for(var i = 0 ; i < 3 ; i++){\n    arr.push(function(){\n      console.log(i)\n    })\n  }\n\n  return arr ;\n}\n\nfs[0]() ;\nfs[1]() ;\nfs[2]() ;\n```\n\n檢驗後答案如你所預期的一樣嗎？如果你答對的話，恭喜你（應該）已經掌握閉包的概念了！\n\n解釋這個例子的原理之前，有必要畫個防雷分隔線：\n\n.\n\n.\n\n.\n\n.\n\n.\n\n.\n\n沒錯，在這個例子中， `fs[0]()` 、 `fs[1]()` 、 `fs[2]()` 執行後，印出的結果都是 `3` 。\n\n許多人預期 `fs[0]()` 、 `fs[1]()` 、 `fs[2]()` 會分別印出 `0` 、 `1` 、 `2` ，怎麼會是 `3` ？這數字哪來的？\n\n簡單來說，這是因為：當你在**執行** `fs[0]()` 這三個函式的時候，它們所參考的外部（詞彙）環境 `buildFunctions()` 所儲存的區域變數 `i` ，已經是 `3` ，和你**創造** `fs[0]()` 這三個函式的時候的 `i` 是不一樣的。 \n\n![黑人問號](./black.jpg)\n\n還是不懂？沒關係，不用害怕，繼續跟我往下走。\n\n<hr>\n\n### 範例解析\n\n綜合過去的觀念，我們一步一步拆解這段程式碼在幹嘛。\n\n首先，在 JS 執行程式碼之前，它會做兩件事，你還記得嗎？\n\n**Creation**： JS 引擎會創造全域執行環境、 `window` 物件，以及 `this` 變數（代指 `window` 物件）。\n\n**Hoisting**： JS 引擎會將變數宣告與函式宣告儲存進記憶體空間，即創造全域變數與全域函式。在這個例子中，變數 `fs` 會先被創造並賦值為 `undefined` ，而函式 `buildFunctions()` 會被宣告完成。\n\n接著， JS 引擎才會真正開始執行程式碼。而第一行程式碼是：\n\n```javascript\nvar fs = buildFunctions() ;\n```\n\n這行程式碼的意思是：\n\n{% colorquote success%}\n呼叫函式 buildFunctions ，並將執行後 return 的值賦予給變數 fs 。\n{% endcolorquote %}\n\n\n所以，我們接著要理解函式 `buildFunctions` 到底執行了什麼？\n\n```javascript\nfunction buildFunctions(){\n  var arr = [] ;\n\n  for(var i = 0 ; i < 3 ; i++){\n    arr.push(function(){\n      console.log(i)\n    })\n  }\n\n  return arr ;\n}\n```\n\n函式 `buildFunctions` 被呼叫後，**JS 引擎會創造屬於它的執行環境**，並開始執行 `{}` 內部的程式碼（也就是函式物件的程式屬性）。\n\n宣告一個區域變數 `arr` 為一個空陣列 `[]`：\n\n```javascript\n  var arr = [] ;\n```\n\n跑一個 `for` 迴圈，若符合條件就執行迴圈內容，反之則結束迴圈：\n\n```javascript\n  for(var i = 0 ; i < 3 ; i++){\n    arr.push(function(){\n      console.log(i)\n    })\n  }\n```\n\n在 `for` 迴圈這部分，我們宣告一個區域變數 `i = 0` 當作計數器，若 `i < 3`，就執行 `for {}` 內的程式碼，反之則跳出迴圈。\n\n每次在 `for {}` 裡面，我們要**創造**一個新的函式 `function(){console.log(i)})` ，並將它 `push` 到變數 `arr` 陣列裡面。\n\n什麼？你說陣列裡面放函式很怪？忘記我們之前說過：陣列是任何東西的集合，可以存放任何純值或（函式）物件。\n\n我們將每一次迴圈的步驟拆開看：\n\n第一次迴圈時， `i = 0` ， `0 < 3` ，符合條件，執行迴圈內容：**創造**函式 `function(){console.log(i)})` 並 `push` 到 `arr` 陣列中，接著 `i ++` 。 \n\n第二次迴圈時， `i = 1` ， `1 < 3` ，符合條件，執行迴圈內容：**創造**函式 `function(){console.log(i)})` 並 `push` 到 `arr` 陣列中，接著 `i ++` 。 \n\n第三次迴圈時， `i = 2` ， `2 < 3` ，符合條件，執行迴圈內容：**創造**函式 `function(){console.log(i)})` 並 `push` 到 `arr` 陣列中，接著 `i ++` 。 \n\n第四次迴圈時， `i = 3` ， `3 < 3` ，不符合條件，跳出迴圈， `for` 迴圈結束。\n\n此時，區域變數 `arr` 為一個陣列，裡面包括三個函式（物件），而區域變數 `i = 3` 。\n\n回傳變數 `arr` 陣列：\n\n```javascript\n  return arr ;\n```\n\n至此，函式 `buildFunctions` 執行完畢，**JS 引擎會消滅屬於它執行環境**。\n\n但是！上篇我們有說，**JS 引擎會保留儲存函式參數與區域變數的記憶體空間**，也就是說，**區域變數 `arr` 和 `i` 仍會存於該函式專屬的記憶體空間，並不會消滅**。\n\n回到全域執行環境，函式 `buildFunctions` 執行後回傳變數 `arr` 陣列，並賦值給變數 `fs` 。\n\n因此 `fs = arr` 。（想一想，是傳值？還是**傳參考？**） \n\n終於來到最後一步：\n\n```javascript\nfs[0]() ;\nfs[1]() ;\nfs[2]() ;\n```\n{% colorquote success %}\n依序呼叫變數 `fs` 裡的三個函式並**執行**。 \n{% endcolorquote%}\n\n `fs[0]` 、 `fs[1]` 、 `fs[2]` 三個函式都指向函式 `function(){console.log(i)})` ，以 `fs[0]()` 為例，JS 執行後，會創造其專屬的執行環境，並開始執行程式：\n\n```javascript\nfunction(){\n  console.log(i)\n}\n```\nJS 引擎知道要執行 `console.log(i)` ，於是開始在函式 `function(){console.log(i)})` 裡面找 `i`，但很顯然，它找不到（因為沒有定義），所以它只好依照**範圍鍊**的規則，向**外部（詞彙）環境**尋找可以取用的 `i` 。\n\n外部詞彙環境是誰？想一想，我們在哪裡**創造**函式 `function(){console.log(i)})` ？\n\n沒錯！就是在函式 `buildFunctions` 裡面！\n\n```javascript\nfunction buildFunctions(){\n  var arr = [] ;\n\n  for(var i = 0 ; i < 3 ; i++){\n    arr.push(function(){\n      console.log(i)\n    })\n  }\n\n  return arr ;\n}\n```\n\n所以，JS 引擎會參考外部（詞彙）環境函式 `buildFunctions` 裡的區域變數 `i` 。\n\n此時 `i` 是多少？ `i = 3` 。\n\n按此邏輯， `fs[0]()` 、 `fs[1]()` 、 `fs[2]()` 印出的結果當然都會是 `3` 了。\n\n<hr>\n\n### 創造函式 v.s. 執行函式 \n\n有些人之所以預期執行結果為 `0` 、 `1` 、 `2` ，那是因為混淆**創造函式**和**執行函式**的時機與差異。\n\n其實，我認為只要釐清**創造函式**和**執行函式**的時機與差異，閉包的原理就很清晰了。\n\n在這個例子中，**創造函式** `function(){console.log(i)})` 的時候，就只是**單純創造該函式**而已，並不會將外部環境的變數 `i` 一起存進記憶體。\n\n等到**執行函式**時， JS 引擎在函式執行環境 `function(){console.log(i)})` 中找不到可用的 `i`（因為它函式內部本身並沒有宣告 `i` 值），所以它會依照範圍鍊，向外部詞彙環境參考可用的值。\n\n**外部詞彙環境**，指的就是，我們在哪裡**創造**函式？或說，函式被我們寫在哪裡？\n\n綜合 JS 種種的特性，形成了閉包的原理：**利用函式執行環境，創造一個封閉空間，包住可供取用的變數**。而那些在範圍鍊中可供取用的變數，又稱為**自由變數（Free Variable）**\n\n總而言之，分清楚**創造（宣告）函式**與**執行（呼叫）函式**的時機以及差異，有助於理解閉包的原理，因為閉包就是綜合這些概念而來。\n\n課程中用這張圖來解釋本篇範例的運作原理：\n\n![函式範例的解釋（圖片源自參考資料 1.）](./closure2.JPG)\n\n<hr>\n\n### 結論\n* 分清楚創造函式與執行函式的時機以及差異，有助於理解閉包的原理。\n* 創造函式時， JS 引擎會創造該函式的記憶體空間，並儲存函式內宣告的變數，並不會將外部環境的自由變數一起存進記憶體（除非以參數傳入）。\n* 執行函式時， JS 引擎如果在函式執行環境中找不到可取用的值，它會依照範圍鍊向外部詞彙環境參考可用的值，直到找到為止。\n* 閉包的原理就是：利用函式執行環境，創造一個專屬的封閉空間（記憶體空間），包住可供取用的變數。\n* 自由變數指的是：函式在範圍鍊中可供取用的變數。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-47","excerpt":"這題沒答對，你敢說你懂閉包？","fields":{"slug":"/weird-JavaScript_32/"},"frontmatter":{"date":"2019-08-26","title":"Wierd JavaScript 32：閉包（2）","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n學了這麼多，現在我們來嘗試理解 JS 小魔王：閉包。\n\n<!-- more -->\n\n### 一級函式\n\nJavaScript 擁有一級函式的特性，**函式（Function）屬於特殊的函式物件，可以被視為一種資料型態**。\n\n所以，我們透過函式 `return` 另一個函式，並連續呼叫、執行，就像這樣：\n\n```javascript\nfunction greet(whattosay){\n  \n  return function(name){\n    console.log(whattosay + ' ' + name) ;\n  }\n}\n\ngreet('Hello!')('John') ;\n```\n\n把函式想像成模板，我們可以傳入所欲的參數，並將它賦值給一個變數，再利用該變數呼叫函式。\n\n```javascript\nfunction greet(whattosay){\n  \n  return function(name){\n    console.log(whattosay + ' ' + name) ;\n  }\n}\n\nvar sayHola = greet('Hola!') ;\nvar sayHello = greet('Hello!') ;\n\nsayHola('John') ;\nsayHello('John') ;\n```\n\n當 JS 讀到 `var sayHola = greet('Hola!') ;` 時，它會創造函式 `greet(whattosay)` 的執行環境，將 `'Hola!'` 作為參數傳入，並回傳匿名函式 `function(name)` 賦值給變數 `sayHola` ，最後消滅函式 `greet(whattosay)` 的執行環境。 \n\n咦？等等，有沒有覺得怪怪的？\n\n既然函式 `greet(whattosay)` 的執行環境已經消滅，為什麼 JS 讀到 `sayHola('John')` 的時候，JS 還記得 `function(name)` 裡的 `whattosay` 指的是 `'Hola!'` ？\n\n同理，為什麼 JS 讀到 `sayHello('John') ;` 的時候，JS 還記得 `function(name)` 裡的 `whattosay` 指的是 `'Hello!'` ？\n\n之前我們不是說，函式裡的**區域變數（Local Variable）**，會隨著函式執行環境生滅嗎？\n\n<hr>\n\n### 函式的執行環境\n\n我們不斷強調，當一個函式被呼叫後，JS 會創造屬於該函式的執行環境，並**分配一小部分的記憶體空間給該函式使用**。\n\n換句話說，**每個函式的執行環境都有屬於自己的記憶體空間**。我們所傳入的**參數**，或是在函式裡創造的**變數（純值或物件）**都會被儲存在該函式專屬的記憶體空間裡面，和其他函式無關，也和全域環境無關。\n\n當函式執行完畢，執行環境被消滅後，基本上， JavaScript 引擎會清除該函式專屬的記憶體空間，這個動作被稱為[垃圾回收（Garbage Collection）](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Memory_Management  )。\n\n然而，**儲存該函式參數和區域變數的記憶體空間並仍會存在**，並不會被清除，這是 JS 引擎本身設計的特色，為了範圍鍊中變數的參考與取用。\n\n在上面的例子中， JS 引擎在 `function(name)` 裡面找不到 `whattosay` ，所以它透過**範圍鍊**向**外部（詞彙）環境** `greet(whattosay)` 尋找可用的變數。在 `greet(whattosay)` 中，儘管函式 `greet(whattosay)` 的執行環境已經消滅，可是， JS 引擎**仍會保留儲存該函式參數和區域變數的記憶體空間**，所以，JS 會取用到 `whattosay` ，等於傳入的參數 `'Hola!'`。\n\n由此可見，`sayHola('John') ;` 的執行結果為 `Hola! John` 。 \n\n<hr>\n\n### 閉包（Closure）\n\n閉包，指的是**利用函式執行環境，創造一個封閉空間，包住可供取用的變數**。\n\n閉包是我們巧用 **JS 引擎會保留儲存函式參數與區域變數的記憶體空間**的特性所產生的方法，可以幫助我們**提升函式彈性**、**避免污染全域變數**。\n\n如同上述的例子，我們利用函式 `greet(whattosay)` 創造執行環境，傳入參數 `whattosay` 的值（`'Hola!'` 或 `'Hello!'`），並回傳另一個函式，供我們調用內部儲存的參數或區域變數。\n\n在課程中利用這張圖來解釋閉包的範例：\n\n![閉包相關概念：一級函式、執行環境、執行堆疊、詞彙環境、外部環境以及範圍鍊（圖片源自參考資料 1.）](./closure.JPG)\n\n<hr>\n\n### 結論\n* 當一個函式被呼叫後，JS 會創造屬於該函式的執行環境，並分配一小部分的記憶體空間給該函式使用。\n* 當函式執行完畢，執行環境被消滅後，儲存該函式參數和區域變數的記憶體空間並仍會存在，並不會被清除。\n* 閉包，指的是利用函式執行環境，創造一個封閉空間，包住可供取用的變數。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-47\n","excerpt":"學了這麼多，現在我們來嘗試理解 JS 小魔王：閉包。","fields":{"slug":"/weird-JavaScript_31/"},"frontmatter":{"date":"2019-08-25","title":"Wierd JavaScript 31：閉包（1）","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n什麼情況下會用到 IIFEs ？\n\n<!-- more -->\n\n### IIFEs與非同步回呼\n\n立即執行函式表達式（IIFEs），指的是我們利用表達式創造函式後，立即呼叫，執行運算，用完就丟。\n\n函式立即呼叫後，JS 會建立屬於它的執行環境，加入執行堆疊，並接著執行程式碼。\n\n函式運算後回傳值（如果有 `return` 的話），消滅執行環境，離開執行堆疊，該 IIFEs 的生命也就結束了，因為只用一次。\n\nIIFEs 用完就丟的特性，讓我們能夠**立即執行非同步回呼**，避免 JS 引擎將它們放進事件佇列，等到最後才逐一執行。\n\n先前我們舉過 `setTimeout` 的例子：\n\n```javascript\nfor(var i = 1 ; i <= 10 ; i ++){\n  setTimeout(function(){\n    console.log('這是第 ' + i + ` 次執行。`) ; \n  },1000)\n}\n```\n\n在這樣的狀況下，JS 引擎會等到執行堆疊為空時，才執行 `setTimeout` 的回呼函式，此時 `i = 11` ，執行結果將會是：\n\n{% colorquote danger %}\n(10) 這是第 11 次執行。\n{% endcolorquote %}\n\n我們可以利用 IIFEs 將 `setTimeout` 包起來，並傳入 `i` ，每跑一次迴圈，就立即執行回呼函式，達到我們預期的效果：\n\n```javascript\nfor(var i = 1 ; i <= 10 ; i ++){\n  (function(i){\n    setTimeout(function(){\n      console.log('這是第 ' + i + ` 次執行。`) ; \n    },1000 * i)\n  })(i) ;\n}\n```\n\n{% colorquote success %}\n這是第 1 次執行。\n這是第 2 次執行。\n...\n這是第 10 次執行。\n{% endcolorquote %}\n\n<hr>\n\n### 安全程式碼（Safe Code）\n\nIIFEs 能夠立即呼叫函式，創造新的執行環境，執行完後隨即消滅。\n\n這樣的特性可以幫助我們**避免污染全域**，**讓只具備功能性的變數隨著執行環境生滅**，而這樣的作法就是所謂**安全程式碼**。\n\n```javascript\n(function(name){\n  \n  var greeting = 'Hello';\n  console.log(greeting + ' ' + name + '.') ;\n})('John') ;\n\nconsole.log(greeting) ; // is not defined\n```\n\n換句話說，我們可以將所欲處理的事情包進 IIFEs 中執行，只 `return` 需要的值，其他沒用的值就不要回傳。\n\n```javascript\n(function(name){\n  \n  var greeting = 'Hello'; // greeting 只是具備功能性的變數，隨著函式執行環境生滅。\n  return greeting + ' ' + name + '.' ;\n})('John') ; \n```\n\n如果我們想要取用全域物件，可以利用物件傳參考的特性，將 `window` 傳入 IIFEs 中，或者直接取用、修改：\n\n```javascript\nvar greeting = 'Hello' ;\n\n(function(global, name){\n  \n  global.greeting = 'Hola' ; \n  // greeting = 'Hola' ; 直接取用，修改全域變數。\n  // var greeting = 'Bonjour' ;  宣告為區域變數，並直接取用。\n  console.log(greeting + ' ' + name + '.') ;\n})(window, 'John') ;\n\nconsole.log(greeting) ; // Hola\n```\n\n<hr>\n\n### 結論\n* IIFEs 能夠立即呼叫函式，創造新的執行環境，執行完後隨即消滅，這樣的特性可以幫助我們避免污染全域，讓只具備功能性的變數隨著執行環境生滅，而這樣的作法就是所謂的安全程式碼。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-45\n\n\n","excerpt":"什麼情況下會用到 IIFEs ？","fields":{"slug":"/weird-JavaScript_30/"},"frontmatter":{"date":"2019-08-24","title":"Wierd JavaScript 30：IIFEs 與安全程式碼","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n有一種函式，我們用完就丟。\n\n<!-- more -->\n\n### 創造函式的方法\n\n至今，我們已經介紹過創造函式的兩種方法，還記得嗎？\n\n* 函式陳述式（Function Statement）\n* 函式表達式（Function Expression）\n\n函式陳述指的是宣告一個**有名字的函式**，具有 Hoisting 的特性，JS 會將宣告的函式逐一存進記憶體，等到我們呼叫時才執行。\n\n下方是一個函式陳述，即函式宣告：\n\n```javascript\ngreet('Bai') ;\n\nfunction greet(name){\n  console.log('HI! ' + name) ;\n}\ngreet('John') ;\n```\n\n函式表達指的是，我們先創造一個**沒有名字的函式**（匿名函式），並將它賦予給一個變數，我們可以透過該變數名稱呼叫函式。\n\n注意！函式表達並沒有 Hoisting 的特性，因此無法在表達前執行。\n\n下方是一個函式表達式：\n\n```javascript\n// greet('Bai') ; // greet is not a funciton\n// console.log(greet) ; // undefined \nvar greet = function(name){\n  console.log('HI! ' + name) ;\n}\ngreet('John') ;\n```\n\n我們說過，**表達式都會產生一個值**，而函式表達之所以屬於表達式，是因為它會創造一個**函式**，並儲存至記憶體，接著**賦值**給另一個變數。\n\n所以，當我們 `console.log()` 該變數，會得到我們所創造的函式。\n\n```javascript\nvar greet = function(name){\n  console.log('HI! ' + name) ;\n}\nconsole.log(greet) ; \n```\n\n還記得函式屬於什麼嗎？\n\n<hr>\n\n### 立即呼叫函式表達式（Immediately Invoked Function Expressions）\n\n**函式屬於特殊的物件**，也就是函式物件，具有名稱屬性與程式屬性，也可以儲存其他屬性或方法。\n\n在函式表達中，我們創造一個匿名函式，雖然它沒有名字，但已經有程式屬性，當然**可以立刻呼叫它**。\n\n怎麼呼叫？一樣，在函式物件後面加上 `()` 。\n\n由於我們要賦值給變數 `greet` ，所以，這裡我們可以利用 `return` 把函式表達改寫成：\n\n```javascript\nvar greet = function(name){\n  return 'HI! ' + name ;\n}('John')\n\n// 此時，變數會等於回傳的值，並非函式本身，自然不能呼叫。\n// greet() ; // greet is not a function\nconsole.log(greet) ;\n```\n\n發現了嗎？我們在創造函式物件的同時，可以立即呼叫它，執行後回傳結果。\n\n既然可以立即呼叫，執行運算，如果這函式我只打算用一次，何必還要賦值給另一個變數，佔記憶體空間？\n\n所以，我們是不是可以這樣寫？\n\n```javascript\nfunction(name){\n  console.log('HI! ' + name) ;\n}('John')\n```\n\n但是 JS 引擎卻告訴你：\n\n![syntaxError（圖片源自參考資料 1.）](syntaxError.JPG)\n\n<br>\n\n<font style=\"font-size: 32px\">JavaScript 笑你，嘻嘻。</font>\n\n這因為 JS 語法解析器看到一段程式碼，如果是由 `function` 開頭，**它會預期這是一段函式陳述句**，必須給函式補上名字。\n\n但函式陳述不能立即呼叫，我們必須想辦法讓程式碼第一個字不為 `function` 。\n\n最簡便的做法，就是利用**群組運算子 `()`**，將匿名函式整個包起來，變成一個**表達式**，這樣就不會是 `function` 起頭了。\n\n```javascript\n(function(name){\n  console.log('HI! ' + name) ;\n})('John') ;\n```\n\n如果你想這樣寫也是可以的：\n\n```javascript\n(function(name){\n  console.log('HI! ' + name) ;\n}('John')) ;\n```\n\n選一種風格，就別再變了吧！\n\n這樣的函式，就是所謂的**立即呼叫函式表達式（IIFEs）**，**利用表達式創造一個函式物件後，立刻呼叫，執行運算，用完就丟**。\n\n蛤？你問為什麼用 `()` 包起來就可以？因為只要在群組運算子 `()` 裡面放任何純值或物件，都會變成表達（創造一個值）。不信你試試：\n\n```javascript\n'I am so hungry.' // 'I am so hungry.'\n( 55 + 66 ) ; // 121\n(function(){console.log('JS is so HARD!!')}) ; // function\n// (function try(){console.log('JS is so HARD!!')}) ; // unexpected token try （有名字的函式不行）\n```\n\n<hr>\n\n### 結論\n* 立即呼叫函式表達式（IIFEs）：利用表達式創造一個函式物件後，立刻呼叫，執行運算，用完就丟。\n* IIFEs 常見於各種框架與資源庫中，當我們不需要重複執行函式時，可以利用 IIFEs 減少記憶體負擔。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-44\n\n","excerpt":"有一種函式，我們用完就丟。","fields":{"slug":"/weird-JavaScript_29/"},"frontmatter":{"date":"2019-08-23","title":"Wierd JavaScript 29：立即呼叫函式表達式（IIFEs）","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n在 JavaScript 中，怎麼使用空格，是門藝術。\n\n<!-- more -->\n\n### 空格（Whitespace）\n\n{% colorquote info %}\n**Invisible characters** that create literal 'space' in your written code.\nCarriage return, Tab and Space.\n{% endcolorquote %}\n\n\n空格在程式碼中表示**創造空間的隱形字元**，譬如 Enter 鍵、 Tab 鍵以及空白鍵。\n\nJavaScript 語法解析器對空格的規範相當自由，且空格字元在程式中並不會被執行，善用空格可以幫助我們寫出可讀性高的程式碼。\n\n雖然下面這段程式碼也是可以執行的，但我們通常不會用這種風格：\n\n```javascript\nvar \na\n=\n55 +\n'66'\n;\nconsole.log(a) ; \n```\n\n搭配註解 `//` 的使用，我們可以在程式碼中紀錄開發歷程。\n\n```javascript\nvar \n  // first name of the person \n  firstname,\n\n  // last name of the person\n  lastname,\n\n  // the language(can be 'en' or 'ch')\n  language ;\n\nvar person = {\n  firstname: 'Fei',\n  lastname: 'Chen',\n  language: 'ch'\n}\n```\n\n<hr>\n\n### 結論\n* 空格在程式碼中表示創造空間的隱形字元，譬如 Enter 鍵、 Tab 鍵以及空白鍵。\n* 空格字元在程式中並不會被執行，善用空格可以幫助我們寫出可讀性高的程式碼。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-43\n\n\n","excerpt":"在 JavaScript 中，怎麼使用空格，是門藝術。","fields":{"slug":"/weird-JavaScript_28/"},"frontmatter":{"date":"2019-08-21","title":"Wierd JavaScript 28：空格","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\nJavaScript 的語法解析器會自動幫我們加上分號，這有時候可能會造成一些問題。\n\n<!-- more -->\n\n### 分號（Semicolon）\n\n先前提過， JavaScript 的語法解析器會幫助我們轉譯程式碼，在過程中也會自動幫我們處理一些事情，進而改變我們的程式碼。\n\n其中一件事是，JS 引擎會**自動幫我們插入分號（Automatic Semicolon Insertion）**。\n\n分號 `;` 在 JavaScript 中沒有任何語意，它的功能是**表示語法段落的結束**。\n\n有寫過 JavaScript 一段時間的人或許會發現，分號在程式碼中並不是必要的，這是因為 **JS 引擎會自動幫我們在必要的地方加上分號**。\n\n譬如 `return` 後面要接的應該是一段表達式，但如果你沒有補上表達式，直接按下 Enter 鍵至下一行繼續撰寫程式碼，JS 會偵測到 `return` 後方的 `carriage return`（按下 Enter 鍵所產生的字元），以為你已經表達完 `retrun` 陳述，因此自動幫你補上分號，確保 `return` 陳述句有效，即什麼都不做（回傳空值），最後讓電腦執行。\n\n舉例來說，你寫的程式碼是這樣：\n\n```javascript\nfunction getName(){\n  return \n  {\n    name: 'Fei'\n  }\n}\n\ngetNam() ; \n```\n\n但 JS 語法解析後會變成這樣：\n\n```javascript\nfunction getName(){\n  return ;\n  {\n    name: 'Fei'\n  }\n}\n\ngetNam() ; \n```\n\n在上例中，原本我們預期想要得到一個物件，執行結果卻是 `undefined` 。這是因為 `return` 後面接著按下 Enter 所產生的 `carriage return` ，所以 JS 語法解析會自動幫我們補上分號，確保語法正確。\n\n我們可以把將物件的左括弧 `{` 接在 `return` 後方，確保 JS 解析語法時，瞭解我們的陳述尚未結束，會接續到下一行。\n\n```javascript\nfunction getName(){\n  return {\n    name: 'Fei'\n  }\n}\n\ngetNam() ; \n```\n\n此時就能如期回傳物件 `{name: 'Fei'}` 。\n\n<hr>\n\n### 結論\n* 在 JavaScript 中，分號不是必要的，但仍**建議在預期的地方加上分號**，避免 JS 引擎解析語法時自動補上所導致的錯誤。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-42\n2. [Javascript 分號戰爭](https://medium.com/cypressyi-technote/javascript-%E5%88%86%E8%99%9F%E6%88%B0%E7%88%AD-4652b218bdf9)\n\n\n\n","excerpt":"JavaScript 的語法解析器會自動幫我們加上分號，這有時候可能會造成一些問題。","fields":{"slug":"/weird-JavaScript_27/"},"frontmatter":{"date":"2019-08-21","title":"Wierd JavaScript 27：自動插入分號","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n再強調一次，什麼是語法解析器？\n\n<!-- more -->\n\n### 語法解析器（Syntax Parsers）\n\n我們在第 01 篇解釋道，語法解析器會幫助我們解析程式碼，並轉換成電腦看得懂的語言（指令），讓電腦執行。\n\n也就是說，我們所寫的程式碼並非由電腦直接執行，會先經過語法解析器轉譯，如果沒有語法錯誤，再由電腦執行我們所寫的程式碼。\n\n語法解析器是 JavaScript 引擎中的一部分，它會一個字一個字解析我們所寫的程式碼，譬如看到 `r` ，它會預期接著 `e` 、 `t` 、 `u` 、 `r` ' `n`， 也就是 `return` ，並解析為 `回傳` 指令，接著預期接下來會出現一串表達式，直到碰到**分號 `;` （Semicolon）**，表示該段落解析結束。如果中間拼字有誤，就會出現 `SyntaxError` 。\n\n![語法解析器碰到分號就會視為一個解析段落的結束（圖片源自參考資料 1.）](./return.JPG)\n\n<br>\n\n在執行程式碼之前，想像語法解析器會**按照規則**，逐字逐行地幫我們解讀程式碼，轉換成電腦能夠理解的語言，且如果需要的話，語法解析器會自己幫我們改變程式碼，以利引擎執行。\n\n無論是哪一種程式語言，理解語法解析器的邏輯與規則，對開發者來說非常重要。\n\n<hr>\n\n### 結論\n* 語法解析器會幫助我們解析程式碼，並轉換成電腦看得懂的語言後，讓電腦執行程式碼。\n* 在執行程式碼之前，想像語法解析器會按照規則，逐字逐行地幫我們解讀程式碼，並轉換成電腦能夠理解的語言，且如果需要的話，語法解析器會自己幫我們改變程式碼，以利引擎執行。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-41\n\n\n","excerpt":"再強調一次，什麼是語法解析器？","fields":{"slug":"/weird-JavaScript_26/"},"frontmatter":{"date":"2019-08-20","title":"Wierd JavaScript 26：語法解析器","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n許多程式語言中都有重載函式的設定，但 JavaScript 卻沒有。為什麼？\n\n<!-- more -->\n\n\n### 重載函式（Function Overloading）\n\n重載函式的意思是，**讓相同的函式擁有不同數量的參數**。\n\n由於在 JavaScript 中，函式屬於特別的函式物件，並不支援重載函式的功能。\n\n不過，也因為函式在 JavaScript 中具有**一級函式**的特色，我們可以利用預設值，或**將功能包裝成另一個函式**，在流程中呼叫。\n\n```javascript\nfunction greet(name, age, city){\n  city = city || 'Taipei' ;\n  if(city === 'Taipei') {\n    console.log('Hello! I am ' + name + ', and ' + age + 'years old. I came from Taiwan.') ;\n  }\n\n  if(city === 'Tokyo') {\n    console.log('Hello! I am ' + name + ', and ' + age + 'years old. I came from Japan ') ;\n  }\n}\n\nfunction greetTaipei(name, age){\n  return greet(name, age, 'Taipei') ;\n}\n\nfunction greetTokyo(name, age){\n  return greet(name, age, 'Tokyo') ;\n}\n\ngreetTaipei('Fei', 23) ;\ngreetTokyo('Bai', 28) ;\n```\n\n<hr>\n\n### 結論\n* 在 JavaScript 中，函式屬於特別的函式物件，並不支援重載函式的功能。\n* 在 JavaScript 中，由於一級函式的特性，我們可以利用預設值或包裝函式的方式，達到重載函式的目的。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-40\n\n\n\n","excerpt":"許多程式語言中都有重載函式的設定，但 JavaScript 卻沒有。為什麼？","fields":{"slug":"/weird-JavaScript_25/"},"frontmatter":{"date":"2019-08-20","title":"Wierd JavaScript 25：重載函式","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n函式的參數（Parameter）和參數 `arguments` 有什麼關係？\n\n<!-- more -->\n\n### 參數（Parameter）\n\n當我們在宣告函式時，會定義所需帶入的數值，也就是 `()` 裡面的變數，這個被丟進函數裡的數就是所謂的**參數（Parameter）**。\n\n```javascript\n// a 和　b 就是函式的參數\nfunction calc(a, b){\n  console.log(a * b) ;\n}\n\ncalc(55, 66) ; // 55 和 66 就是函式 calc 的參數\n```\n\n### 參數（Arguments）\n\n而在 JavaScript 中有一個關鍵字也叫作**參數： `arguments`**，它跟變數 `this` 一樣，在函式執行後被創造，指的是**函式執行環境裡，那些被丟進來的參數們**。\n\n![函式呼叫後的創造階段：創造執行環境、this、arguments以及參考外部環境（圖片源自參考資料 1.）](./argument.JPG)\n\n<br>\n\n{% colorquote info %}\nThe parameters you pass to a function.\nJavaScript gives you a keyword of the same name which contains them all.\n{% endcolorquote %}\n\n\n簡單來說，`arguments` 就是**函式參數的集合**，它會以**類陣列（Array-like）**的形式存在於函式執行環境中，供我們取用。\n\n```javascript\nfunction calc(a, b){\n  console.log(arguments) ; // Arguments(2):[55, 66]\n}\n\ncalc(55, 66) ;\n```\n\n必須謹記！ `arguments` 是**類陣列**，而不是陣列。雖然它擁有部分陣列的特性，但**大多數陣列可以使用的方法， `argument` 都不能使用**。\n\n不過，我們可以透過**取用運算子 `[]`** 來取用 arguments 裡的某一個參數。\n\n```javascript\nfunction calc(a, b){\n  console.log(arguments[1]) ; 66\n}\n\ncalc(55, 66) ;\n```\n\n在 JavaScript 中，我們可以設定函式所欲代入的參數，但真正執行時卻不一定要代入參數，這不會導致 JS 報錯。\n\n當我們執行函式並代入參數時，必須**由左至右**逐一代入定義的參數，任意跳過都是不被 JS 接受的。\n\n如果沒有參數被丟進函式，JS 引擎仍會執行函式，由於變數 Hoisting 的特性，沒有代入的參數會自動被定義成 `undefined` 。\n\n```javascript\nfunction calc(a, b, c){\n  console.log(a) ; \n  console.log(b) ; \n  console.log(c) ; // undefined\n  console.log(arguments) ; // Arguments(2):[55, 66]\n}\ncalc(55, ,66) ; //  SyntaxError: Unexpected token\ncalc(55, 66) ; \n```\n\n在 ES6 之後，我們可以在宣告函式時**設定參數的預設值**，或直接在函式區塊內透過邏輯運算子 `||` 設定預設值，避免 `undefined` 。\n\n```javascript\nfunction calc(a, b, c=100){\n  b = b || 66 ;\n  console.log(a) ; \n  console.log(b) ; \n  console.log(c) ; // 100\n  console.log(a * b * c) ; \n}\ncalc(55) ; \n```\n\n我們可以利用 `arguments.length` 的方法來**判斷傳入參數的數量**或參數是否為 `undefined`：\n\n```javascript\nfunction calc(a, b, c=100){\n  if(arguments.length === 0){\n    return ; // 結束函式(不做任何事)\n  }\n  console.log(a * b * c) ; \n}\ncalc() ; \n```\n\n在 ES6 以後，我們可以透過**展開運算子（Spread Operator） `...`** 將陣列中的值逐一展開後丟進函式中處理：\n\n```javascript\nconst nums = [1, 2, 3] ;\nfunction calc(a, b, c){\n  console.log(a * b * c) ; // 6\n}\ncalc(...nums) ; \n```\n\n<hr>\n\n### 結論\n* 函式被呼叫後，JS 引擎會自動幫我們宣告一個變數 `arguments` 。\n*  `arguments` 是函式參數的集合，會以類陣列的形式存在於函式執行環境中供我們取用。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 3-39\n\n","excerpt":"函式的參數（Parameter）和參數  有什麼關係？","fields":{"slug":"/weird-JavaScript_24/"},"frontmatter":{"date":"2019-08-17","title":"Wierd JavaScript 24：參數（parameter v.s. arguments）","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n講了那麼多的物件和函式，現在終於輪到不可或缺的邊緣人－陣列。\n\n<!-- more -->\n\n### 陣列（Array）\n\n陣列屬於物件型別的次型別，又稱**陣列物件**，它的內容可以是**任何東西的集合**。\n\n也就是說，我在陣列裡面可以放任何的資料型別，包含字串、數字、布林、物件、函式物件、甚至另一個陣列。\n\n```javascript\nvar arr = [\n  'Bai',\n  false,\n  function(name){\n    console.log('Hola! ' + name) ;\n  },\n  5566,\n  {\n    mom: 'Linda',\n    city: 'Taipei',\n    isCute: true\n  },\n  ['Eat','Sleep','Play Games']\n]\nconsole.log(arr) ;\n```\n\n我們知道物件是 Name/Value Pairs 的集合，其實陣列物件也是同樣的道理，只是它用**索引值（Index）**取代了 Name。\n\n陣列的索引值由左至右從 `0` 開始，如果把上面的程式碼想像成陣列物件如下：\n\n```javascript\nvar arr = [\n  0: 'Bai',\n  1: false,\n  2: function(name){\n    console.log('Hola! ' + name) ;\n  },\n  3: 5566,\n  4: {\n    mom: 'Linda',\n    city: 'Taipei',\n    isCute: true\n  },\n  5: ['Eat','Sleep','Play Games']\n]\n```\n\n我們可以透過**取用運算子 `[]`** 搭配索引值來取用物件內的資料。注意！**物件的點運算子在陣列中是不能使用的**。\n\n```javascript\narr.2(arr.4.mom) ; // SyntaxError: Unexpected number\narr[2](arr[4].mom) ; // Hola! Linda\n```\n\n<hr>\n\n### 結論\n* 陣列屬於特殊的陣列物件，它可以是任何資料型別的集合。\n* 我們可以利用取用運算子 `[]` 搭配陣列索引值來取用陣列裡的資料。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-38 \n\n","excerpt":"講了那麼多的物件和函式，現在終於輪到不可或缺的邊緣人－陣列。","fields":{"slug":"/weird-JavaScript_23/"},"frontmatter":{"date":"2019-08-17","title":"Wierd JavaScript 23：陣列","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n你指的 this 到底是哪個 this ？\n\n<!-- more -->\n\n### 回顧函式的執行環境\n\n經過前面一連串的講解，我們知道，當一個函式被呼叫後，JS 引擎會為該函式創造屬於它的**執行環境**。而執行環境本身就是該函式中區域變數的**變數環境**，也就是**作用域的範圍**。我們還可以依據函式所處的**詞彙環境**，判斷函式執行時，如果找不到所需的變數，JS 會參考到的**外部環境**為何。\n\n除此之外，當新的函式執行環境被創造時，JS 引擎也會幫我們建立一個新的變數 `this` 。\n\n課程歸納如下：\n\n![函式執行環境創造階段：建立執行環境、this、判斷外部環境（圖片源自參考資料 1.）](./creationPhase.JPG)\n\n在第 03 篇介紹全域環境時，我們說過，全域環境就是全域物件 `window` ，此時變數 `this` 指的就是全域物件。\n\n```javascript\nvar a = 5566 ;\nconsole.log(window) ;\nconsole.log(this) ;\nconsole.log(window.a === this.a) ; // true\n```\n\n但是，當函式被呼叫後，在該函式的執行環境中，變數 `this` 所代指的對象是會改變的。\n\nSo, what is \"this\" ?\n\n<hr>\n\n### this\n\n{% colorquote info %}\nIn most cases, the value of this is determined by **how a function is called**. (MDN)\n{% endcolorquote  %}\n\n`this` 是一個**變數**（代名詞），在一個函式被呼叫時，它會在新的執行環境中被建立，而 `this` 所指涉的對象取決於**該函式如何被呼叫**。\n\n什麼樣的情況叫做**如何被呼叫**？\n\n有個簡單的法則是：在**大部分**的狀況下，我們可以透過**函式被誰呼叫**來判斷`this` 所代指的對象。\n\n簡言之，`this` 會指向**呼叫該函式的物件**。\n\n雖然這個法則適用於大部分狀況，但**有例外**。\n\n#### 純粹呼叫（Simple Call）\n\n我們用程式碼舉例說明，首先，以全域為例：\n\n```javascript\nfunction a(){\n  console.log(this) ; // window\n}\nvar b = function(){\n  console.log(this) ; // window \n}\na() ; \nb() ;\n```\n\n我們會發現，呼叫函式 `a` 與函式 `b` 後，在兩者的執行環境中，變數 `this` 都會指向全域物件 `window` 。\n\n因為，在這個例子，函式 `a` 與函式 `b` 都是**被全域物件呼叫**的，所以 `this` 會代指全域物件 `window` ，這樣看或許比較清楚：\n\n```javascript\nwindow.a() ; \nwindow.b() ;\n```\n\n接著，我們把函式 `b` 放進函式 `a` ：\n\n```javascript\nvar name = 'Bai'\n\nfunction a(){\n  console.log(this.name) ; // Bai\n  var name = 'Fei'\n  \n  var b = function(){\n    console.log(this.name) ; // Bai \n  }\n\n  b() ;\n}\na() ; \n```\n\n此時我們會發現，儘管函式 `b` 在函式 `a` 中被呼叫，但函式 `a` 與函式 `b` 中的 `this` 都指向全域物件 `window`，因此會取用到 `Bai`。\n\n為什麼？~~老實說，我也不清楚。~~只能說，JavaScript 的設計就是這樣（？）\n\n我的解釋是：雖然函式 `b` 在函式 `a` 中，但**呼叫函式 `b` 的依舊是全域物件 `window`** ，仔細觀察， `b()` 並**沒有被誰呼叫**，因此 `this` 依然指向 `window`。\n\n像這樣直接呼叫函式，被稱為**純粹呼叫（Simple Call）**，此時變數 `this` 都會指向全域物件 `window`。\n\n那什麼叫**做被誰（物件）呼叫**？\n\n#### 呼叫物件方法（Call Object Method）\n\n**呼叫物件方法（Call Object Method）**，就是函式被物件呼叫：\n\n```javascript\nvar name = 'Bai' ;\nvar person = {\n  name: 'Fei',\n  say: say // 物件裡的 name/value 其中的 value 為函式，就屬於物件的方法。\n}\nfunction say(){\n  console.log(this.name) ;\n}\n\nsay() ; // Bai \nperson.say() ; // Fei \n```\n\n同理， `say()` 被全域物件呼叫（可以看成 `window.say()` ），所以 `this.name` 等同於 `window.name` ，讀到的值為 `Bai`。\n\n而 `person.say()` ，呼叫函式 `say` 的物件就是它前面的物件 `person` ，也就是說，在函式 `say` 執行時，其執行環境內所創造的 `this` 會指向呼叫函式 `say` 的物件 `person` ，所以 `this.name` 等同於 `person.name` ，讀到的值就會是 `Fei` 。\n\n你可能會覺得，咦？可是物件 `person` 的方法 `say` 是參考全域物件中的函式 `say`，但這和 `this` 無關，**`this` 指涉的對象只取決於哪一個物件呼叫該函式**。\n\n#### 純粹呼叫與呼叫物件方法\n\n最後，我們結合純粹呼叫和呼叫物件方法的例子：\n\n```javascript\nvar person = {\n  name: 'Fei',\n  greet: function(){\n    function reviseName(newName){\n      this.name = newName ;\n    }\n    reviseName('Foo') ; // 儘管處在函式 greet 裡，但仍屬於純粹呼叫，this 代指 window。\n    console.log(this.name) ; // Fei　\n  } \n}\nperson.greet() ; \nconsole.log(name) ; // Foo　；全域物件會新增一個變數 name ，其值為 Foo 。\n```\n\n同樣的道理，許多人看到函式 `reviseName` 處在物件 `person` 中，就誤解函式 `reviseName` 裡面的 `this` 也會指向物件 `person` ，但**並不是**，因為 **`this` 指涉的對象取決於函式如何被呼叫**， `this` 在函式執行後才會出現作用，跟函式本身在哪裡被宣告沒有關係，這點要特別小心。\n\n是以，在這個例子中，函式 `reviseName` 被純粹呼叫，其 `this` 代指的就會是全域物件 `window` ，會在全域中新增一個變數 `name` 其值為 `Foo` 。\n\n如果要達到修改物件 `person` 中 `name` 的目的，我們可以利用執行環境中變數作用域以及範圍鍊的特性，在函式 `greet` 中**宣告新的變數（通常會命名為 `self` 或 `that` ），並賦予 `this` 的值**： `person`（在函式 `greet` 中 `this` 代指 `person`），讓子函式 `reviseName` 可以向外參考取用到該變數，以修改物件 `person` 中的 `name` 。\n\n方法如下：\n\n```javascript\nvar person = {\n  name: 'Fei',\n  greet: function(){\n    var self = this ;\n    function reviseName(newName){\n      self.name = newName ;\n    }\n    reviseName('Foo') ; \n    console.log(self.name) ; // Foo \n  } \n}\nperson.greet() ;\n```\n\n弄懂 this 在純粹呼叫與物件方法呼叫上的指涉差異，我們就能判斷大部分情況 this 代指的對象了。\n\n由於 this 的例外狀況還有很多，詳細請容我日後再介紹，有興趣的朋友可以先閱讀參考資料中的大神文章，對 this 的理解會更加深刻。\n\n<hr>\n\n### 結論\n* `this` 是一個變數（代名詞），在一個函式被呼叫時，它會在新的函式執行環境中被建立。\n* 在**大部分**的狀況下，`this` 會指向呼叫該函式的物件，但有例外狀況。\n* 當函式被純粹呼叫時，`this` 都會指向全域物件 `window` 。\n* 當函式被物件呼叫（呼叫物件方法）時，`this` 會指向呼叫該函式的物件。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-37\n2. [MDN：this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)\n3. [重新認識 JavaScript: Day 20 What's \"THIS\" in JavaScript (鐵人精華版)](https://ithelp.ithome.com.tw/articles/10193193)\n4. [淺談 JavaScript 頭號難題 this：絕對不完整，但保證好懂](https://github.com/aszx87410/blog/issues/39)\n5. [卡斯伯：鐵人賽：JavaScript 的 this 到底是誰？](https://wcc723.github.io/javascript/2017/12/12/javascript-this/)\n\n","excerpt":"你指的 this 到底是哪個 this ？","fields":{"slug":"/weird-JavaScript_22/"},"frontmatter":{"date":"2019-08-16","title":"Wierd JavaScript 22：What's this ?","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n傳值 v.s. 傳參考， JavaScript 偷偷做但不告訴你的概念。\n\n<!-- more -->\n\n### 資料型別\n\n回顧 JavaScript 的資料型別，可以分為兩大類，共七種。哪兩類？哪七種呀？\n\n1. 基本型別類（Primitive）\n  * String\n  * Number\n  * Boolean\n  * Null\n  * Undefined\n  * Symbol\n2. 物件型別類（Object）\n  * Object (Function / Array)\n\n其中，基本型別的六種值會以**純值**的方式表現，而物件型別中的**物件則是 Name/Value 的集合**，換句話說，**物件也是許多資料型別的集合。**\n\n除此之外，我們也說過，當宣告新的變數或值（物件）時，JS 都會將這些資料型別分別存進記憶體，而變數在讀取值時，其實是參照的是值在記憶體中的位置（Address）。\n\n搞懂上面這兩個觀念之後，傳值與傳參考的原理就呼之欲出了！\n\n<hr>\n\n### 傳值（by Value）\n\n在 JavaScript 中，**基本型別（純值）**的變數賦值或拷貝大部分是以**傳值**的方式實現。\n\n什麼意思？我們可以這樣解釋：因為基本型別本身就是**純值**，所以無論變數賦值，或是複製變數，大部分都是**傳遞（純）值**。\n\n直接舉例說明：\n\n```javascript\nvar a = 100 ;\nvar b = a ; // 複製變數\nconsole.log(a,b) ; // 100 100\na = 200 ;　//  變數更新（重新賦值）\nconsole.log(a,b) ; // 200 100\n```\n\n我們宣告變數 `a` 並賦值 `100` ，接著宣告變數 `b` ，並讓它的值等於 `a` 。此時，JS 引擎在複製變數 `a` 的值時，會傳遞值 `100` 並賦予給變數 `b` ，使變數 `b` 值也等於 `100`。（如第 3 行結果）\n\n如果我們接著修改變數 `a` ，賦值 `200` ，此時變數 `a` 更新後的值等於 `200`，而變數 `b` 的值仍然是 `100`，並沒有改變。\n\n也就是說，基本型別在賦予變數值、複製變數或更新（重新賦值）變數時，JS 引擎會參照到該值在記憶體中的位置，並傳遞值本身，**為複製的變數建立一個新的記憶體位置來儲存傳遞的值**。\n\n所以，在上面這段範例中，第 2 行執行後，變數 `a` 和變數 `b` 雖然都是 `100` ，但這**兩個變數所參考的記憶體位置並不一樣**，以致修改變數 `a` 後，變數 `b` 不受影響。\n\n課程中以這張圖來說明傳值的概念：\n\n![傳值：變數儲存新的純值到新的記憶體位置（圖片源自參考資料 1.）](./byValue.JPG)\n\n<hr>\n\n### 傳參考（by Reference）\n\n在 JavaScript 中，**物件型別（物件、函式、陣列）**的變數賦值或拷貝大部分是以**傳參考**的方式實現。\n\n同樣的思維，我們可以這樣解釋：因為物件型別本身就是**物件（許多資料型別的集合）**，所以無論變數賦值，或是複製變數，大部分都是**傳遞參考（物件）**。\n\n什麼是**參考**？也就是變數所參考到**儲存物件的記憶體位置（Address）**。因此，傳參考又稱為**傳址**。\n\n請看下方範例：\n\n```javascript\nvar a = {\n  name: 'Fei',\n  age: 23\n} ;\nvar b = a ; // 複製變數\nconsole.log(a,b) ; // {name: \"Fei\", age: 23} {name: \"Fei\", age: 23}\na.age = 17 ;　//  變數更新（重新賦值）\nconsole.log(a,b) ; // {name: \"Fei\", age: 17} {name: \"Fei\", age: 17}\n```\n\n由於物件**傳參考**的特性，第 5 行執行後，變數 `a` 和變數 `b` 這**兩個變數所參考的記憶體位置是相同的**，都指向儲存物件 `{name: \"Fei\", age: 23}` 的位置。\n\n也就是說，物件型別在賦予變數值、複製變數或更新（重新賦值）變數時，JS 引擎會參照到該物件在記憶體中的位置，並傳遞參考位置，**複製的變數會同樣參考到物件儲存的記憶體位置**。\n\n換句話說，物件並不像純值那樣會被複製到新的記憶體位置中。背後的真相是：**物件不會被複製（新建記憶體位置儲存）**。\n\n是以，第 7 行執行後，修改變數 `a` 物件裡的 `age` 值，等同修改了變數 `b` 物件裡的 `age` 值，因為變數 `a` 和變數 `b` 這兩個變數所參考的記憶體位置是相同的，指的是同一個物件。\n\n其實，我們也曾經說過，JavaScript 物件中的每個 Name/Value 都各自擁有不同的記憶體位置，既然如此，我們可以想成：儲存物件的記憶體位置，該物件在取用屬性或方法時，也會參考到儲存其所擁有的 Name/Value 的記憶體位置。\n\n因此，我們必須將物件視為一個**實體（Instance）**，當我們更新物件裡的屬性或方法時，**修改（Mutate）**的正是 Name/Value 記憶體位置的**值**，這當然會更動到所有參考到該物件實體的變數。\n\n或許是考量效率問題，JS 在更新或複製變數時，若碰到物件資料，會以傳參考（指向相同記憶體位置）的方式實現。試想，如果要像純值那樣複製值本身，倘若物件擁有上百個 Name/Value Pairs 該怎麼辦？效率肯定會變差。那直接指向相同物件（的記憶體位置）不更省事？\n\n因為物件是 Name/Value 的集合，也是儲存 Name/Value 記憶體位置的集合。\n\n最後，還有一個觀念：**物件被傳入函式中執行，同樣擁有傳參考的特性**。\n\n```javascript\nvar a = {\n  name: 'Fei',\n  age: 23\n} ;\nvar b = a ;\n\nfunction mutateProperty(obj){\n  obj.age = 17 ; // 修改物件的屬性\n}\nmutateProperty(a) ;\nconsole.log(a,b) ; // {name: \"Fei\", age: 17} {name: \"Fei\", age: 17}\n```\n\n課程以這張圖來說明傳參考的概念：\n\n![傳參考：變數會參考到相同物件的記憶體位置（圖片源自參考資料 1.）](./byReference.JPG)\n\n<hr>\n\n### 結論\n* 在 JS 中，基本型別（純值）在賦予變數值、複製變數或更新（重新賦值）變數時，JS 引擎會參照到該值在記憶體中的位置，並傳遞值本身，為複製的變數建立一個新的記憶體位置來儲存傳遞的值。\n* 在 JS 中，物件型別（物件、函式、陣列）在賦予變數值、複製變數或更新（重新賦值）變數時，JS 引擎會參照到該物件在記憶體中的位置，並傳遞參考位置，複製的變數會同樣參考到物件儲存的記憶體位置。此外，物件被傳入函式中執行也擁有傳參考的特性。\n* 變數賦值、複製或更新（重新賦值），可以歸納到使用賦值運算子 `=` 的情境，此時純值會傳值，物件會傳參考。\n* 賦值運算子 `=` 的意義在於，若賦值資料是第一次宣告，則 JS 會新建記憶體位置儲存該資料，並賦值給左方變數。\n* 傳值或傳參考的歸納符合大部分的狀況，但有例外，且目前學界對於 JS 究竟是傳值、傳參考還是傳享（by Sharing）？並無定論，有興趣的人可以進一步參考下方資料文章。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-36\n2. [重新認識 JavaScript: Day 05 JavaScript 是「傳值」或「傳址」？](https://ithelp.ithome.com.tw/articles/10191057)\n3. [深入探討 JavaScript 中的參數傳遞：call by value 還是 reference？](https://blog.techbridge.cc/2018/06/23/javascript-call-by-value-or-reference/)\n\n","excerpt":"傳值 v.s. 傳參考， JavaScript 偷偷做但不告訴你的概念。","fields":{"slug":"/weird-JavaScript_21/"},"frontmatter":{"date":"2019-08-15","title":"Wierd JavaScript 21：傳值 v.s. 傳參考","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n JavaScript 的兩種句型：陳述式和表達式。\n\n<!-- more -->\n\n### 表達式（Expression）\n\n{% colorquote info %}\nA unit of code that **results in a value**.\nIt doesn't have to save to a variable.\n{% endcolorquote  %}\n\n\n表達式的**執行結果會回傳一個值**，而該值不一定要賦予給任一變數。譬如運算、賦值、呼叫函式等等。\n\n```javascript\na = 55 ; // 55\n5 * 6  ; // 30\n'a' + 'b' ; // 'ab'\nfalse + 100 ; // 100\n```\n\n<hr>\n\n### 陳述式（Statement）\n\n{% colorquote info %}\nA unit of code that would not result in a value.\n{% endcolorquote  %}\n\n陳述式的執行結果不會回傳值。譬如 `var` 宣告、函式宣告、 `switch` 判斷、 `{}` 函式區塊、 `break` 等等。\n\n有些陳述式會需要表達式產生值後才能運作，譬如 `if` 。\n\n```javascript\nvar a ;\nif(a === 3){ ... } // 其中 a === 3 屬於表達式，若回傳 true ，執行 {} 內程式碼\n```\n\n**函式陳述式**也就是函式宣告。我們在 04 篇說過，函式宣告在全域環境具有 Hoisting 的效果，能在宣告之前呼叫函式。\n\n```javascript\ngreet() ;\nfunction greet(){\n  console.log('Function declaration statement would be hoisted in JS.')\n}\n// greet() 函式物件的名稱屬性： greet\n// greet() 函式物件的程式屬性： { console.log('Function declaration statement would be hoisted in JS.') }\n```\n\n<hr>\n\n### 函式表達式（Function Expression）\n\n既然**函式**屬於一種特殊的**函式物件**，當然能夠**被賦予給任一變數**，這樣的方式稱為函式表達式。\n\n唯要特別注意的是，將函式物件於賦予任一變數後，我們**就能用該變數名稱參照到該函式物件**，因此在表達函式物件時，不需要另外定義函式物件的名稱屬性，也就是說，必須使用**匿名函式（Anonymous Function）**來表達函式物件。\n\n然而，函式表達並非函式陳述，因此並沒有 Hoisting 的效果，必須等到變數被賦予函式物件後，才能用該變數呼叫函式。\n\n```javascript\nanonymousGreet() ; // anonymousGreet is not a function ; anonymousGreet 會先被宣告為 undefined！\nvar anonymousGreet = function(){\n  console.log('Function expression could be anonymous.')\n}\nanonymousGreet() ; // 必須等到賦予函式物件後才能呼叫\n```\n\n<hr>\n\n### 一級函式與函式表達\n\n在 JS 中，由於一級函式的特色，我們可以將一個函式物件當作另一個函式的參數，丟進函式中執行。\n\n結合函式表達的概念，我們能將一個儲存函式物件的變數當作參數丟進另一個函式中，並在函式中呼叫該函式：\n\n```javascript\nvar greet = function(num1,num2){\n  console.log(num1 + num2) ;\n}\n\ncall(greet) ;\nfunction call(a){\n  a(55,66) ; // 121\n}\n```\n\n當然，我們也可以立即創造一個函式，將它當作參數丟進另一個函式並執行：\n\n```javascript\ncall(function(name){\n  console.log('Hola! '+ name)\n}) ;\n\nfunction call(a){\n  a('John') ; // Hola! John\n}\n```\n\n<hr>\n\n### 結論\n* 表達式的執行結果會回傳一個值；陳述式的執行結果不會回傳值。\n* 函式陳述式指的是函式宣告，在全域環境中具有 Hoisting 特性，能夠在宣告之前呼叫。\n* 函式表達式指的是將一個函式（物件）賦予任一個變數。\n* 結合一級函式的特色，參考到函式物件的變數可以被當作參數丟進另一個函式中執行並回船結果。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-35\n2. [MDN：Statements and declarations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements)\n3. [MDN：Function expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function)\n\n\n\n","excerpt":"JavaScript 的兩種句型：陳述式和表達式。","fields":{"slug":"/weird-JavaScript_20/"},"frontmatter":{"date":"2019-08-15","title":"Wierd JavaScript 20：函式陳述式與函式表達式","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n函式就是物件，物件就是函式，就是所謂一級函式。\n\n<!-- more -->\n\n### 函式就是物件\n\n我們之前談到資料型別時，就已經提過：在 JavaScript 中，**函式是一種特殊的物件**。\n\n也就是說，我們也可以賦予函式屬性以及方法：\n\n```javascript\nfunction personSay(){\n  console.log('The function is an object in JavaScript!') ;\n}\n\npersonSay.who = 'John' ;\npersonSay.age  = 28 ;\npersonSay.yell = function(){console.log('JS is Soooooo HARD!!')} ;\n\nconsole.log(personSay.who) ; // John\npersonSay.yell() ; // JS is Soooooo HARD!!\n```\n\n而這樣的函式特色，在程式語言中被稱為**一級函式（First Class Functions）**。\n\n<hr>\n\n### 一級函式（First Class Functions）\n\n{% colorquote info %}\nEverything you can do with other types you can do with functions.\nAssign them to variables, pass them around, create them on the fly.\n{% endcolorquote  %}\n\n上面這段對於一級函式的簡介意思是：任何你對其它型別做的事情，你都可以用一級函式做到。\n\n蛤？好拗口？這是什麼意思？\n\n意思就是，基本上，**你可以利用一級函式做任何事情！**包括將函式賦予給變數、將函式當作參數傳入另一個函式、利用實字語法建立函式、賦予函式屬性或方法等等。\n\n現在聽起來很抽象，往後介紹**閉包（Closure）**時，就能夠深入理解一級函式的威力。\n\n雖然一級函式並非 JavaScript 獨有的特色，但因為具備這樣的特性，使得 JavaScript 成為一種**以函式為核心（Functional Programming）**的程式設計語言。\n\n<hr>\n\n### 函式物件\n\n在 JS 中，函式屬於一種特殊的物件，又稱為**函式物件**。\n\n而物件本身是 Name/Value Pairs 的集合，因此函式物件可以擁有**屬性**或**方法**。\n\n除了屬性或方法以外，函式物件還包括兩個我們不知道的特殊屬性：**名稱屬性（Name）**以及**程式屬性（Code）**。\n\n函式物件的名稱屬性指的就是**函式名稱**。函式可以有名字，也可以沒有名字，沒有名字的函式又稱**匿名函式（Anonymous Function）**。\n\n函式物件的程式屬性指的就是**函式程式區塊**，也就是 `{}` 內我們所寫的程式碼部分，而且，這個程式屬性是**能夠被呼叫的（Invocable）**，也就是在函式名稱後方加上 `()`。\n\n```javascript\nfunction yell(){\n  console.log('JS is Soooooo WEIRD!!')\n}\n// yell 就是函式物件的名稱屬性\n// {console.log('JS is Soooooo WEIRD!!')} 就是函式物件的程式屬性\n// 利用 名稱屬性() 來呼叫執行程式屬性\nyell() ; \n```\n\n順便回顧一下，當我們呼叫函式後，會建立新的執行環境，以執行函式的程式區塊，也就是 `{}` 內的程式碼，而 `{}` 內的環境同時也是該函式中區域變數作用域的範圍。\n\n課程以這張圖歸納了函式物件的組成：\n\n![函式物件的構成：名稱屬性、程式屬性、屬性、方法（圖片源自參考資料 1.）](./functionObject.JPG)\n\n<hr>\n\n### 結論\n* 在 JavaScript 中，函式是一種特殊的物件，而這樣的特色被稱為一級函式。\n* 在 JavaScript 中，函式屬於函式物件，可以擁有屬性與方法。\n* 函式物件的組成包括：名稱屬性（可以是匿名的）、程式屬性（能夠被呼叫的）、屬性、方法。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-34\n","excerpt":"函式就是物件，物件就是函式，就是所謂一級函式。","fields":{"slug":"/weird-JavaScript_19/"},"frontmatter":{"date":"2019-08-14","title":"Wierd JavaScript 19：一級函式","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n什麼？你說 JSON 就是物件？大錯特錯！\n\n<!-- more -->\n\n### JSON\n\nJavaScript 物件表示法（JSON， JavaScript Object Notation），是一種輕量的資料交換語言，用來傳輸 Name/Value Pairs 所組成的資料物件。JSON 雖然屬於 JavaScript 中的子集，但是獨立於 JS 環境，可以被許多程式語言支援、解析，副檔名為 `.json`。\n\n相較於 XML（Extensible Markup Language），由於 JSON 更加**輕便、簡潔明瞭（在傳輸上不會浪費過多的頻寬，效率更高）**，當今開放資料多半以 JSON 格式開源，然而由於格式特性，兩者使用上還是有慣用的語言環境。JSON 常見於 JavaScript、Java、Node.js ，而 XML 常見於 PHP、C# 等網頁應用。\n\nJSON 格式：\n\n```json\n{\n  \"name\": \"John\",\n  \"age\": 28,\n  \"sex\": \"male\",\n  \"isStudent\": false\n}\n```\n\nXML 格式：\n\n```xml\n<?xml version=\"1.0\"?>\n<object>\n  <name>John</name>\n  <age>28</age>\n  <sex>male</sex>\n  <isStudent>false</isStudent>\n</object>\n```\n\n<hr>\n\n### JSON與Object的比較\n\nJSON 和 JS 物件的格式差異在於，**JSON 中的 Name/Value 一定要用雙引號 `\"\"` 包覆**，JS Object 則沒有規定。 \n\nJSON 格式：\n\n```json\n{\n  \"name\": \"John\",\n  \"age\": 28,\n  \"sex\": \"male\",\n  \"isStudent\": false\n}\n```\n\nJS 物件格式：\n\n```javascript\nvar obj = {\n  name: 'John',\n  age: 28,\n  sex: 'male',\n  isStudent: false\n}\n```\n\n<hr>\n\n### JSON轉Object\n\nJavaScript 內建 `JSON.parse()` 指令，能將 **JSON 格式的字串（String）轉換成 JS 物件**。\n\n```javascript\nvar obj = JSON.parse('{\"name\":\"John\",\"age\": 28,\"sex\": \"male\",\"isStudent\": false}') ;\nconsole.log(obj) ; // Object: {name: \"John\", age: 28, sex: \"male\", isStudent: false}\n```\n\n<hr>\n\n### Object轉JSON\n\nJavaScript 內建 `JSON.stringify()` 指令，能將 **JS 物件換成 JSON格式的字串（String）**。\n\n```javascript\nvar json = JSON.stringify({\n  name: 'John',\n  age: 28,\n  sex: 'male',\n  isStudent: false\n}) ;\nconsole.log(json) ; // JSON String: {\"name\":\"John\",\"age\":28,\"sex\":\"male\",\"isStudent\":false}\n```\n\n<hr>\n\n### 結論\n* JSON 是一種發想於物件實字的輕量化資料交換格式，常見於開放資料。\n* 和物件格式不同的是，JSON 中的 Name/Value **一定要**用雙引號 `\"\"` 包覆。\n* `JSON.parse()` 能將 JSON 字串轉換成 JS 物件。\n* `JSON.stringify()` 能將 JS 物件轉換成 JSON 字串。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-33\n2. [維基百科：JSON](https://zh.wikipedia.org/wiki/JSON#举例)\n3. [維基百科：XML](https://zh.wikipedia.org/wiki/XML#%E7%BB%93%E6%9E%84)\n\n","excerpt":"什麼？你說 JSON 就是物件？大錯特錯！","fields":{"slug":"/weird-JavaScript_18/"},"frontmatter":{"date":"2019-08-14","title":"Wierd JavaScript 18：JSON v.s. 物件","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n當我們想要用相同的變數名稱來代指相似的資料，可以利用物件來建立偽裝的命名空間，避免資料被覆寫。\n\n<!-- more -->\n\n### 命名空間（Namespace）\n\n{% colorquote warning %}\nA container for variables and functions.\nTypically to keep variables and functions with the same name seperate.\n{% endcolorquote %}\n\n\n命名空間指的是一個程式語言中**儲存變數與函式名稱的容器**，它的功用在於分離相同名稱的變數與函式。\n\n然而， **JavaScript 沒有 Namespace** 這項功能。因此，當我們想要用同一個變數名稱來指涉相似的資料，後者所定義的值，往往會覆蓋掉前面所定義的值。\n\n```javascript\nvar greet = 'Hello!' ;\nvar greet = 'Hola!'  ;\nconsole.log(greet) ; // Hola!\n```\n\n解決這樣的方法就是，借助物件的特性，**假裝創造各自獨立的命名空間**。\n\n<hr>\n\n### 偽裝命名空間\n\n利用物件實字 `{}` 建立新物件，並將相同變數分別儲存進不同的物件中。\n\n此時，即便我們擁有兩個相同的變數名稱，但因為分屬不同物件，兩者都會被存進電腦記憶體，各自獨立存在，不會被覆寫。\n\n```javascript\nvar greetEng = {} ;\nvar greetSpn = {} ;\ngreetEng.greet = 'Hello!' ;\ngreetSpn.greet = 'Hola!'  ;\nconsole.log(greetEng.greet,greetSpn.greet) ; // Hello! Hola!\n```\n\n注意！如果想在物件中建立一個新的物件，必須**先宣告（初始化）物件**，才能將變數或函數存進去，否則 JS 會因為找不到該物件，而將物件判定為 `undefined` ，以致取用運算子失效。\n\n```javascript\n  var greetEng = {} ;\n  greetEng.greet = 'Hello!' ;\n  // greetEng.say = {} ; 先宣告物件就可以執行\n  greetEng.say.morning = 'Good morning!' ; // cannot set property of undefined \n```\n\n<hr>\n\n### 結論\n* 命名空間指的是一個程式語言中儲存變數與函式名稱的容器，但 JavaScript 並沒有這項功能。\n* 在 JS 中，當我們想要用同一個變數名稱來指涉相似的資料，可以利用物件來偽裝命名空間。\n* 必須先宣告（初始化）物件後，才能開始在物件中新增屬性或方法。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-32\n\n\n","excerpt":"當我們想要用相同的變數名稱來代指相似的資料，可以利用物件來建立偽裝的命名空間，避免資料被覆寫。","fields":{"slug":"/weird-JavaScript_17/"},"frontmatter":{"date":"2019-08-14","title":"Wierd JavaScript 17：偽裝命名空間","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n學習取用物件的屬性和方法。\n\n<!-- more -->\n\n### 物件的屬性與方法\n\n在 JavaScript 中，物件與函式息息相關，因為**函式是一種特殊的物件**，兩者不應分開討論。\n\n我們一再強調，物件就是 **Name/Value 的集合**，具有**屬性**和**方法**。\n\n物件中的屬性指的是物件中的一組 Name/Value ，其 Value 屬於另一個**基本型別（純值）或物件型別**。\n\n物件中的方法指的是物件中的一組 Name/Value ，其 Value 屬於另一個**函式**。\n\n```javascript\nvar person = {\n  // Property: 一組 Name/Value ，其中 Value 是'Fei'（純值）\n  name: 'Fei', \n  // Property: 一組 Name/Value ，其中 Value 是一個物件。\n  family: {\n    dad: 'Jason',\n    mom: 'Teresa',\n    bro: 'Bai'\n  },\n  // Property: 一組 Name/Value ，其中 Value 是一個陣列，因為陣列也屬於物件的一種。\n  friends: ['Shiba','giraffe','Fish'],\n  // Method: 一組 Name/Value ，其中 Value 是一個函式，因為函式也屬於物件的一種。\n  say: function(){\n    console.log('Welcome to my blog!!') ;\n  }\n} ;\n```\n\n值得注意的是， JS 引擎創造物件時，除了**整個物件本身**會被儲存在一個**記憶體位置（Address）**，其中**所有的屬性或方法**也會分別被存進記憶體中。\n\n當我們在存取、修改物件中的某一個屬性或方法時，其實 JS 引擎所指向的是儲存該屬性或方法的記憶體位置，而非整個物件儲存的記憶體位置。\n\n只有當我們在取用整個物件時，JS 引擎才會指向儲存整個物件的記憶體位置。\n\n物件、物件中的屬性與方法在記憶體中的儲存位置，對於傳值、傳參考的概念非常重要！\n\n總而言之，可以用課程中的這張圖來總結物件的結構：\n\n![物件的組成（圖片源自參考資料 1.）](./object.JPG)\n\n<hr>\n\n### 屬性取用運算子\n\n我們可以利用屬性取用運算子 `[]` 來存取物件內的屬性，或呼叫物件內的方法。記得呼叫函式都要以 `()` 來呼叫。\n\n注意， `[]` 內要用**字串（String）**來表示我們想取用的屬性或方法名稱（Name）：\n\n```javascript\nconsole.log(person['name']) ; // Fei\nconsole.log(person['family']) ; // { dad: 'Jason', mom: 'Teresa', bro: 'Bai'}\nconsole.log(person['family']['bro']) ; // Bai\nperson['say']() ; // Welcome to my blog!!\n```\n\n除此之外，我們也可以用**物件專屬的取用運算子** `.` 來存取物件內的屬性或呼叫物件內的方法。與 `[]` 不同的是，我們不需要用字串來表示所欲取用的 name，因此使用上更為簡潔。\n\n```javascript\nconsole.log(person.name) ; // Fei\nconsole.log(person.friends) ; // ['Shiba','giraffe','Fish']\nconsole.log(person.friends[2]) ; // Fish\nperson.say() ; // Welcome to my blog!!\n```\n\n從 [MDN 所整理的運算子優先性表格](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)中，可以發現 **`.` 運算子與 `[]` 運算子的優先次序是第二高的**，僅次於群組運算子 `()` ，且為左相依性，**由左至右**運算。\n\n當然，我們也可以利用 `.` 運算子與 `[]` 運算子新增、修改物件的屬性或方法：\n\n```javascript\nperson.hobby = ['Coding, Singing, Traveling'] ;\nperson['family'].sis = 'Mei' ;\nperson.say = function(){console.log('JS is so WEIRD!!')} ;\n```\n\n<hr>\n\n### 結論\n* 物件是 Name/Value 的集合 ，每一組鍵值配對都是一組屬性或方法。\n* JS 創造物件時，會把物件整個存進一個記憶體位置，也會將每一個屬性或方法分別儲存進不同的記憶體位置。\n* 我們可以用 `[]` 或 `.` 運算子新增、修改、取用物件的屬性或呼叫物件的方法。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 4-30\n","excerpt":"學習取用物件的屬性和方法。","fields":{"slug":"/weird-JavaScript_16/"},"frontmatter":{"date":"2019-08-13","title":"Wierd JavaScript 16：物件的屬性、方法以及取用","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n請用物件實字法創造物件。\n\n<!-- more -->\n\n### 物件實字（Object Literals）\n\n物件實字，就是用 `{}` 來創造一個新的物件，並直接在裡面定義我們所欲的 Name/Value Pairs。\n\n```javascript\nvar favoriteFood = {\n  name: 'Fei',\n  delicacy: {\n    taiwanese: ['oyster omelet', 'egg roll'],\n    westerm: ['spaghetti','fried chicken'],\n    japan: ['sashimi', 'ramen']\n  },\n  drink: ['bubble tea', 'latte'],\n  moneyLeft: 877 \n}\n```\n\n物件實字本身簡潔明瞭，是最常被用來創造物件的方法，其本身也可以**被當作參數傳入函式**：\n\n```javascript\nfunction callName(person){\n  console.log('Hello! I\\'m ' + person.name + '. I am ' + person.age + ' years old.') ;\n}\ncallName({\n  name: 'Fei',\n  age: 23 \n}) ;\n```\n\n#### new Object() \n\n另一種方式是，用 `new Object()` 創造物件後，利用 `.` 或 `[]` 運算子一一新增所欲的屬性和方法，使用上不比實字表示法來得方便直覺。\n\n```javascript\nvar John = new Object() ;\n\nJohn.age = 30 ;\nJohn.hobby = ['eat', 'sleep', 'working'] ;\nJohn['residence'] = new Object() ;\nJohn['residence']['city'] = 'Taipei' ;\nJohn['residence']['district'] = 'Daan' ;\nconsole.log(John) ;\n```\n\n<hr>\n\n### 結論\n* 創造物件有兩種方式：利用物件實字 `{}` 或 `new Object()` 。\n* 實務上多以物件實字法創造物件，但部分時候還是會用到 new 建構式來創造物件。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 3-31\n\n","excerpt":"請用物件實字法創造物件。","fields":{"slug":"/weird-JavaScript_15/"},"frontmatter":{"date":"2019-08-12","title":"Wierd JavaScript 15：創造物件、物件實字","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n小飛：「所以， JS 的動態型別與強制型轉到底有什麼用？」\n\n有！這兩大特色幫助我們輕鬆判斷條件，設定預設值。\n\n<!-- more -->\n\n### 存在與布林\n\n既然在 JavaScript 中資料型別可以任意轉換，這也就表示**任何資料都能被我們轉型成布林值**：`true` 或 `false`。\n\n在 JS 中，我們可以用 `Boolean()` 這個指令來檢驗資料轉型的布林值為何？\n\n```javascript\nBoolean('') ;         // false ;\nBoolean(0)  ;         // false ;\nBoolean(null) ;       // false ;\nBoolean(undefined) ;  // false ;\n```\n\n從此可知，我們知道 `空字串`、`0`、`null`、`undefined` 在布林中都會被轉成 `false`，在 JS 中，我們可以說這些**值不存在**，或說**什麼都不是（Nothing）**。\n\n而布林值的判別，能夠幫助我們檢驗資料的值是否存在，並用在條件判斷中進行流程管理。譬如 **`if` 陳述句**， `if` 條件的判斷取決於**條件內容的布林值**，若為 `true` ，就執行 `{}` 內的程式碼，若否，則執行 `else{}` 或結束判斷。\n\n```javascript\nvar a = '    ' ; // 注意！空字串和空白字串是不一樣的！\nvar b = 0 ;\n\n// === 優先性高於 &&，所以先判斷 b === 0 為 true，再判斷 a && true。\n// 由於 a 為空白字串，轉成布林值為 true ，所以條件內容為 true && true，執行 {} 程式碼。\nif(a && b === 0){\n  console.log('Something is there.') ; // Something is there.\n}\n```\n\n<hr>\n\n### 設定預設值\n\n我們也可以利用邏輯運算子 `||（或）` ，借助強制型轉與布林值的特性，來為變數賦予預設值。\n\n邏輯運算子 `||（或）` 的意義是，**由左至右判斷中介雙方的資料的布林值**，若左方變數的布林值為 true ，即回傳左方的資料，若左方布林值為 false ，則進一步判斷右方資料的布林值，若為 true ，即回傳右方資料。\n\n以下方程式碼為例：\n\n```javascript\nfunction welcome(name){\n  name = name || 'my guest' ;\n  console.log('Welcome to my blog, ' + name + '!') ;\n}\nwelcome('John') ; // Welcome to my blog, John! \nwelcome() ; // Welcome to my blog, my guest! \n```\n\n<hr>\n\n### 結論\n* 在 JS 中任何資料都能被轉型成布林值。\n* 布林值的判別能夠幫助我們檢驗資料的值是否存在，並用在 `if` 條件判斷中進行流程管理。\n* 我們也可以利用邏輯運算子 `||` ，借助強制型轉與布林值的特性，來為變數賦予預設值。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 3-27、3-28\n\n\n\n","excerpt":"小飛：「所以， JS 的動態型別與強制型轉到底有什麼用？」 有！這兩大特色幫助我們輕鬆判斷條件，設定預設值。","fields":{"slug":"/weird-JavaScript_14/"},"frontmatter":{"date":"2019-08-12","title":"Wierd JavaScript 14：存在與布林、條件判斷與預設值","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n強制型轉（Coercion）， JavaScript 偷偷幫我們處理但不告訴我們的事情之一。\n\n<!-- more -->\n\n### 強制型轉（Coercion）\n\n{% colorquote warning %}\nConverting a value from one type to another.\nThis happens quite often in JavaScript because it's dynamically typed.\n{% endcolorquote  %}\n\n\n由於 JavaScript 屬於動態型別的語言，語法對於資料型態並沒有嚴格的規範，以致型別之間的轉換相當容易，所以，**當碰到不同資料型別之間的運算或判斷時，JS 會（貼心？）偷偷幫我們轉換資料型別進行判斷**，這就是所謂的**強制型轉**。\n\nJS 強制型轉的特色是有跡可循的，我們先從字串運算子講起。\n\n#### 字串運算子（String Operator）\n\n字串運算子中只有 `+` 這個運算子，它除了可以作為算術中的加法，還可以**串起兩邊的字串**。\n\n字串運算子的重點在於，**只要 `+` 雙邊有一個資料屬於字串，那麼另一個資料就會被強制型轉為字串**，並串起兩字串。\n\n```javascript\n// + 串起兩字串\n'哈囉你好嗎？' + '衷心感謝！' ; // 哈囉你好嗎？衷心感謝！\n// + 串起數字與字串\n'55' + 66 ; // 5566\n55 + '66' ; // 5566\n// + 串起布林與字串\nfalse + 'true' ; // falsetrue \n```\n\n注意！字串運算子只有 `+` 可以串起兩字串，沒有 `-` 這個運算子的！\n\n最近看到這個 JavaScript is weird 的解析結果，試著結合運算子的優先性與相依性想想看：\n\n```javascript\n('b'+'a'+ +'a'+'a').toLowerCase() ;\n// 'banana' ... JS 真的很怪 ...\n```\n\n#### 算術運算子\n\n我們之前提過算術運算子用來處理基本的數學運算，但如果遇到的不是數字型別的資料呢？\n\n請記得，**只要算術運算子中介的任一方屬於數字型別，那麼另一方除了字串型別以外，都會被轉成數字型別加以運算**。\n\n```javascript\n// + 對數字與布林進行運算\n100 + true ; // 101　　\n100 + false ; // 100\n// + 對數字與 null 進行運算\n100 + null ; // 100\n// + 對數字與 undefined 進行運算\n100 + undefined ; // NaN\n// + 對數字與 NaN 進行運算\n100 + NaN ; // NaN\n```\n\n由上方程式碼可見，某些特殊純值型轉為數字後的值：\n\n* `true = 1`\n* `false = 0`\n* `null = 0`\n* `undefined = NaN`\n\n<hr>\n\n#### 比較運算子\n\n我們在系列第 11 篇中有說明比較運算子屬於**左相依性**，因此我們判斷時應該從左邊向右邊看，以這個神奇的範例說明 JS 的判斷原理：\n\n```javascript\nconsole.log(3 < 2 < 1) ; // true\n\n// 上面這段程式碼在 JS 引擎看起來是這樣：\n1. console.log((3 < 2) < 1) ; // 小於 < 屬於左相依性，先看 3 < 2 ，邏輯正確，回傳布林值 false。\n2. console.log( false  < 1) ; // 再看 false < 1 ，比較布林值 false 與 1 ， false 會被強制型轉為 0。\n3. console.log(    0   < 1) ; // 比較 0 與 1 ，邏輯正確，回傳布林值 true 。\n```\n\n### 嚴格等於\n\nJS 強制型轉的特色讓不同的資料型態放在一起時得以被轉型運算，就某種角度來看，是非常強大的功能。但，也因為強制型轉的特性可能會導致非預期的 BUG，所以，在實務上，我們會以 **`===`（嚴格等於）**來判別兩資料在**值**與**資料型別**是否都**相同**，避免使用 `==`（寬鬆等於）只比較兩資料的值，讓 JS 強制型轉其中一方資料而出現錯誤。\n\n[MDN：Equality comparisons and sameness](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness) 整理了兩數相等性的歸納表格，詳細內容可以點進去參考。\n\n<hr>\n\n### 結論\n* 強制型轉指的是，JS 處理不同資料型別之間的運算或判斷時，會強制轉換資料型別進行處理。\n* 在字串運算子中，若兩參數有一方是字串型別，則另一方也會被轉成字串型別，進行字串串連。\n* 在算數運算子中，若兩參數有一方是數字型別，則另一方（字串除外）也會被轉成數字型別，進行數字計算。\n* 在判斷運算子處理時，必須綜合考慮運算子的優先性、相依性以及 JS 強制型轉的特性。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 3-24、3-26\n\n","excerpt":"強制型轉（Coercion）， JavaScript 偷偷幫我們處理但不告訴我們的事情之一。","fields":{"slug":"/weird-JavaScript_13/"},"frontmatter":{"date":"2019-08-12","title":"Wierd JavaScript 13：強制型轉","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n瞭解運算子的優先性與相依性，我們才知道許多種類的運算子擺在一起時，誰會先處理？從哪裡開始處理？\n\n<!-- more -->\n\n\n### 優先性（Operator Precedence）\n\n{% colorquote warning %}\nWhich operator function gets called first.\n{% endcolorquote %}\n\n\n運算子的優先性指的是，哪一個運算子會優先被 JS 引擎呼叫執行？\n\n也就是說，許多運算子擺一起時， **JS 會先執行擁有較高優先次序的運算子**。\n\n以算術運算子為例，很常見的「先乘除後加減」在 JS 亦如是：\n\n```javascript\n// 乘法、除法在 JS 中的優先次序為 14 。\n// 加法、減法在 JS 中的優先次序為 13 。\n// 賦值在 JS 中的優先次序為 3 。 \n// 因此 4 * 5 會先被執行，而後為 3 + 20 ，得到 23 ，會後賦值給變數 num。\nvar num = 3 + 4 * 5 ; \nconsole.log(num) ; // 23\n```\n\n<hr>\n\n### 相依性（Operator Associativity）\n\n{% colorquote warning %}\nWhat order operator functions get called in: **Left-to-right** or **Right-to-left**.\nWhen operator functions have the same precedence. \n{% endcolorquote %}\n\n相依性指的是，**當運算子具有相同優先性時，運算子執行的方向為何？**分為兩種：\n\n* **左相依性（Left-to-right）**\n* **右相依性（Right-to-left）**\n\n我們在上一篇中提到運算子執行的方向性，即相依性，用以判斷優先性相同的情境。\n\n以賦值運算子為例，請看下方程式碼：\n\n```javascript\n// 賦值在 JS 中的優先次序為 3 ，屬於右相依性（從右邊開始往左邊看）。 \nvar a = 3 , b = 4 , c = 5 ;\na = b = c ; \n// c 會將值 5 向左賦值給 b 使其為 5，又 b 向左賦值給 a 使其為 5，以致 a、b、c 最後的值都是 5。\nconsole.log(a) ; // 5\nconsole.log(b) ; // 5\nconsole.log(c) ; // 5\n```\n\n<hr>\n\n### 結論\n* 運算子的優先性指的是，JS 會處理擁有高優先次序的運算子。\n* 運算子的相依性指的是，當運算子具有相同優先次序時，運算子執行的方向。\n* 運算子的優先性與相依性可以參考 [MND 所整理的表格](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 3-22\n","excerpt":"瞭解運算子的優先性與相依性，我們才知道許多種類的運算子擺在一起時，誰會先處理？從哪裡開始處理？","fields":{"slug":"/weird-JavaScript_12/"},"frontmatter":{"date":"2019-08-11","title":"Wierd JavaScript 12：運算子的優先性與相依性","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n運算子就是用符號表示的函式。\n\n<!-- more -->\n\n### 運算子（Operators）\n\n{% colorquote info %}\n**A special function** that is syntactically (written) differently.\nGenerally operators take two parameters and return one result.\n{% endcolorquote %}\n\n如同其他程式語言，在 JavaScript 中，運算子是**一種特殊的函式**，透過特殊符號來描述，且往往**需要至少兩個以上的參數（Parameters）**進行運算，以回傳（return）一個運算的結果。\n\n以算術運算子中的 `+` 為例，請看下方程式碼：\n\n```javascript\nvar a = 55 + 66 ;\n```\n\n大部分運算子使用的是[中綴（Infix）](https://zh.wikipedia.org/wiki/%E4%B8%AD%E7%BC%80%E8%A1%A8%E7%A4%BA%E6%B3%95)表示法，意即用 `+` 串聯兩個所欲計算的參數 `55` 和 `66` 。\n\n這段程式碼如果用 JS function 語法來表示，就像這樣（注意！只是幫助理解，請不要執行）：\n\n```javascript\nfunction +(a,b){\n  return a + b ;\n}\n+(55,66)\n```\n\n當然，也部分運算子包括所謂[前綴（Prefix）](https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95)與[後綴（Postfix）](https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95)表示法。如下面這些範例：\n\n```javascript\nvar c = 100 ;\nvar d = 200 ;\n// Prefix\nconsole.log(++c) ; // 101\n// Postfix \nconsole.log(d--) ; // 200\n```\n\nJavaScript 包含以下幾種功能的運算子：\n\n* 賦值運算子\n* 比較運算子\n* 算術運算子\n* 位元運算子（不常用）\n* 邏輯運算子\n* 條件運算子（又稱三元運算子）\n* 逗點運算子\n* 字串運算子\n* 一元運算子\n* 關係運算子\n\n大家有空可以點進連結細讀 [MDN 關於各種運算子的詳細介紹](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Guide/Expressions_and_Operators)。\n\n這裡我想簡單介紹幾種常見常用的運算子。\n\n#### 算術運算子（Arithmetic operators）\n\n算術運算子包括基本的數學運算方法，必須掌握的算術運算子如下：\n\n```javascript\n// 加法\n100 + 2 ; // 102\n// 減法\n100 - 2 ; // 98\n// 乘法\n100 * 2 ; // 200\n// 除法\n100 / 3 ; // 33.33333333...\n// 取餘數\n100 % 3 ; // 1\n// 指數\n2 ** 3 ; // 8\n// 增加（++）以及減少（--）：屬於一元運算子，根據前綴或後綴的表述方法會回傳不同結果。\n// 前綴增加／減少會回傳參數加／減 1 後的值：\nconsole.log(++100) ; // 101\n// 後綴增加／減少會將參數加／減 1 ，但回傳原本的值：\nconsole.log(100++) ; // 100\n```\n\n#### 賦值運算子（Assignment operators）\n\n賦值運算子是**將右方的參數賦予給左方**，這個方向性很重要！\n\n賦值運算子可以結合算術方法，變成複合的賦值運算子。\n\n常見如下：\n\n```javascript\n// 單純賦值\nvar x = 5566 ;\nvar y = x ;\n// 加法賦值\nvar k += 100 ; // 等同於　k = k + 100 \n// 減法賦值\nvar l -= 200 ; // 等同於　l = l - 200\n// 依此類推... \n```\n\n#### 比較運算子（Comparison operators）\n\n比較運算子會**由左至右**依序比較傳入的參數，並根據結果回傳布林值： `true` 或 `false`。\n\n如果比較的兩個參數資料型別不同，由於 JS 的動態型別特性，它會偷偷幫我們**強制型轉（Coercion）**後進行比較。\n\n除了常見的比較運算子，**等於**和**嚴格等於**值得一提：\n\n```javascript\n// 等於：比較兩個參數的數值是否相同？\nconsole.log(55 == 55) ; // true\n// 嚴格等於：比較兩個參數的數值以及資料型態是否相同？\nconsole.log(55 === '55') ; // false \n```\n\n實務上，我們會**使用 `===` 來進行判斷**，以避免 JS 偷偷幫我們強制型轉而產生紕漏。\n\n#### 邏輯運算子（Logical operators）\n\n邏輯運算子會**由左至右**判斷傳入的**參數**或**運算式**，並根據結果回傳一個**其中一個參數**，或**布林值**： `true` 或 `false`。\n\n邏輯運算子常被用在條件判斷，尤其是 `if` 陳述句：\n\n```javascript\n// 且（&&）：當參數為運算式，根據運算結果回傳布林值，若兩運算式結果皆為 true ，則回傳 true。\nconsole.log( 5 < 6 && 8 < 2) ; // false\n// 或（||）：當參數為運算式，根據運算結果回傳布林值，若兩運算式其中之一為 true ，即回傳 true。\nconsole.log( 5 < 6 || 8 < 2) ; // true\n// 非（!）：若參數轉換成布林值為 true，則回傳 false。\nconsole.log(!5566) ; // false \nconsole.log(!!5566) ; // true ；表示 5566 的布林值為 true\n// 用於 if 陳述：\nif(5 < 6 && 6 < 7){\n  console.log('This is TRUE!') ; // This is TRUE!\n}else{\n  console.log('This is FALSE!') ;\n}\n```\n\n注意！在 JS 中，**應該避免同時三個值以上的多重判斷**，尤其在 `if` 等條件陳述中，JS 強制型轉的特色可能會導致非預期的結果：\n\n```javascript\n// 尷尬的案例 ˊ_>ˋ\nif(3 < 2 < 1){\n  console.log('This is TRUE!') ; // This is TRUE!\n}else{\n  console.log('This is FALSE!') ;\n}\n```\n\n所以，在**判斷多重條件時，請使用邏輯運算子**確保嚴謹：\n\n```javascript\nif(3 < 2 && 2 < 1){\n  console.log('This is TRUE!') ; \n}else{\n  console.log('This is FALSE!') ; // This is FALSE!\n}\n```\n\n<hr>\n\n### 結論\n* 運算子是一種透過特殊符號來表述的函式。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 3-21\n2. [MDN：Expressions and operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators)","excerpt":"運算子就是用符號表示的函式。","fields":{"slug":"/weird-JavaScript_11/"},"frontmatter":{"date":"2019-08-11","title":"Wierd JavaScript 11：運算子","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\nJavaScript 將資料分為基本型別與物件型別兩類，那麼 JS 內建的資料型別到底有幾種呢？\n\n<!-- more -->\n  \n<hr>\n\n### 資料型別（Data Type）\n\n其實在 02 篇就已經大概介紹過，在 JavaScript 中，資料型別分為兩類：\n\n1. 基本型別／原始型別（純值）\n2. 物件型別（物件）\n\n也就是說，在 JS 中，所有的**值（Value）**都是**純值**或**物件**。\n\n更精闢一點地說，**所有的值，都是物件**。（這個概念比較進階，等到我們更深入瞭解物件後，就能理解。）\n\n這篇主要介紹這兩大資料型別。\n\n<hr>\n\n### 基本型別（Primitive）\n\n{% colorquote info %}\nA type of data that represent **a single value**.(Not an object)\n{% endcolorquote %}\n\n基本型別，又稱**原始型別**，又細分為六種，每一種都是**值（Value）**，因此基本型別指的就是：**「純值」**。\n\n什麼意思？相較於**物件**作為 **Name/Value 的集合體**，基本型別就只有它這個**值（Value）**。\n\n而這六種值分別是：\n\n#### 字串（String）\n\n{% colorquote info %}\na sequence of characters.\n{% endcolorquote %}\n\n\n用**單引號（'Fei'）**或**雙引號（\"Fei\"）**包覆的內容就屬於字串，如 `'Fei'` 、 `'5566'` 、 `\"True\"` 、 `'undefined'` 等等。\n\n注意！單引號與雙引號混用是不被接受的： ~~`\"Fei'`~~ 。\n\n我會推薦使用**單引號（''）**來表達字串，因為使用雙引號的話，如果字串內容遇到雙引號或其他特殊字元，就必須作**跳脫字元（Escape Character）**處理，單引號少有這樣的衝突。如下範例：\n\n```javascript\nvar noteA = '\"JavaScript\" is not equal to \"Java\"!!' ;\nvar noteB = \"\"JavaScript\" is not equal to \"Java\"!!\" ;\nconsole.log(noteA) ;　// \"JavaScript\" is not equal to \"Java\"!!\nconsole.log(noteB) ;　// SyntaxError: Unexpected identifier\n\n// 利用反斜線（\\）跳脫字元後，noteB 即可執行：\nvar noteB = \"\\\"JavaScript\\\" is not equal to \\\"Java\\\"!!\" ;\n```\n\n#### 數字（Number）\n\n{% colorquote info %}\nfloating point number.\nUnlike other programming languages, there's only one 'number' type.\n{% endcolorquote %}\n\n和其他語言不同， JavaScript 的數字型別都屬於**浮點數（Float）**。\n\n除了常見的整數或小數，JS 還包含一些特別的數字：\n\n* `Infinity`（無限大）\n* `-Infinity`（無限小）\n* `NaN`（不是數字，Not a Number）\n\n任何正數除以 `0` 都會得到 `Infinity` ；反之，任何負數除以 `0` 都會得到 `-Infinity`。\n\n`Infinity` 除以 `Infinity` 會得到 `NaN`。\n\n`0` 除以 `0` 也會得到 `NaN`。\n\n其實，只要任何運算中出現 `NaN` ，結果都會是 `NaN`。\n\n `NaN` 甚至不等於自己，更別說等於任何數字。但是， `NaN` 還是屬於**數字型別（Number）**。\n\n如果你想判斷一個變數或值是不是 `NaN` ，可以用 `isNaN()` 來判斷。\n\n```javascript\nconsole.log(NaN === NaN) ; // false\nconsole.log(NaN === 100) ; // false\nisNaN('NaN') ; // true ；因為 'NaN' 無法轉成其他數字。\ntypeof NaN ; // Number ；NaN 屬於數字型別（Number）。\n```\n\n回到數字型別本身，由於 JS 對 Number 的處理採用的是「[IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754)」二進位浮點數算術標準，在運算上會出現極其微小的誤差，導致某些運算式的判斷會令人不解，經典案例如下：\n\n```javascript\nconsole.log(0.1 + 0.2 === 0.3) ; // false\n```\n\n#### 布林值（Boolean）\n\n{% colorquote info %}\ntrue or false\n{% endcolorquote %}\n\n~~斯斯有三種，但~~ Boolean 只有兩種值： `true`（是） 和 `false`（否）。\n\nBoolean 多被用來判斷運算式，藉此控制流程，決定要不要做某一件事，譬如 `if` ：\n\n```javascript\nvar a = 55 ;\nvar b = 66 ;\nif(a > b){　// 55 > 66 不成立， a > b 會被轉成 false 代入 if，因此 if(false)\n  console.log('a is LARGER than b.') ;  // 這段不會執行。\n}else{\n  console.log('a is SMALLER than b.') ; // 執行這段，印出 a is SMALLER than b.  \n}\n```\n\n在 JavaScript 中，判斷或比較的運算式能夠被隱性轉型成 Boolean ，好比上面這段程式碼中的 `` ，詳細我們不久後就會提到。\n\n#### 空值（Null）\n\n{% colorquote info %}\nnull represents lack of exitence.\n{% endcolorquote %}\n\nNull 只有 `null` 這個值，指的是，該變數存在於 JS（記憶體） 中，**已經被宣告，可能曾經有值，但現在沒有值**。\n\n如果你不想讓一個變數有前述三種值，那麼將它設定為 `null` 是**可以被接受的**，因為在必要時，它會被 JS **強制轉型**成 `0` 進行運算。請看下方程式碼：\n\n```javascript\nvar num = 5566 ;\nvar nul = null ;\nvar und = undefined ;\nconsole.log(num + nul) ; // 5566\nconsole.log(num + und) ; // NaN　ˊ<_ˋ...??????\n```\n\n#### 未定義（Undefined）\n\n{% colorquote info %}\nUndefined represents lack of existence.\n{% endcolorquote %}\n\n\nUndefined 只有 `undefined` 這個值，指的是，該變數存在於 JS（記憶體） 中，**已經被宣告，但尚未被賦值**。\n\n一個變數如果是 `undefined` ，代表變數沒有其他值（字串、數字、null等等），才會被賦值為 `undefined`。\n\n還記得 Hoisting 嗎？ JS 在 Hoisting 階段時，會先幫我們宣告變數並賦予 `undefined` ，等到它真正執行後，才真正賦值。\n\n我們可以說， `undefined` 是 JS 用來告訴我們**變數未被賦值**的狀況。\n\n注意！請不要將變數賦值為 `undefined`，因為它需要運算時，會被 JS **強制轉型** 為 `NaN` ，如上方範例。\n\n所以， `undefined` 真正的意涵，表示**變數佔據記憶體位置**，但是變數還沒有被賦予其它值。\n\n總結來說，對 JS 而言， `null` 與 `undefined` 具有**值不存在**的意思，但實際上兩者在功能與運算仍有差異，不然何必無緣無故設計兩種型別呢？\n\n#### Symbol（ES6 新增的型別）\n\n{% colorquote info %}\nUsed in ES6. We won't talk about this here...\n{% endcolorquote %}\n\n\nES6 後才新增的型別，因為不常見~~（我也還不會用）~~，這裡先不談。\n\n最後，在介紹物件型別之前，我要先簡單介紹一個很重要的觀念：\n\n在 JavaScript 中，**基本型別（上述六種值）**的變數賦值或拷貝（Copy）大部分是以**傳值（by Value）**的方式實現。\n\n聽不懂？沒關係，我們會再細談的。\n\n<hr>\n\n### 物件型別（Object）\n\n相較於基本型別有六種（純值），物件型別只有一種，就是**物件（Object）**。\n\n什麼是物件？我們說過，物件是**Name/Value（鍵值配對） 的集合體**，每一對 Name/Value 都是物件的**屬性（Property）**，其中， Value 可以是其他純值或物件。\n\n創造物件有很多種方式，最常見的是**物件實字（Object Literal）**，我們用程式碼來看會比較清楚：\n\n```javascript\nvar person = {\n  // Property: 一組 Name/Value ，其中 Value 是'Fei'（純值）\n  name: 'Fei', \n  // Property: 一組 Name/Value ，其中 Value 是一個物件。\n  family: {\n    dad: 'Jason',\n    mom: 'Teresa'\n  }\n} ;\n```\n\n好，重點來了！物件型別只有一種，就是物件（Object），但它擁有**次型別（subtype）**，常見的有這兩個：\n\n* **陣列（Array）**，又稱為陣列物件。\n* **函式（Function）**，又稱為函式物件。\n\n當然還包括其他次型別物件，等我們有遇到再介紹。\n\n所以，物件內容其實可以很複雜：\n\n```javascript\nvar person = {\n  // Property: 一組 Name/Value ，其中 Value 是'Fei'（純值）\n  name: 'Fei', \n  // Property: 一組 Name/Value ，其中 Value 是一個物件。\n  family: {\n    dad: 'Jason',\n    mom: 'Teresa',\n    bro: 'Bai'\n  },\n  // Property: 一組 Name/Value ，其中 Value 是一個陣列，因為陣列也屬於物件的一種。\n  friends: ['Shiba','giraffe','Fish'],\n  // Method: 一組 Name/Value ，其中 Value 是一個函式，因為函式也屬於物件的一種。\n  say: function(){\n    console.log('Welcome to my blog!!') ;\n  }\n} ;\n```\n\n物件中的函式 ，我們稱之為物件的**方法（Method）**，既然是 function ，當然可以呼叫。\n\n使用**點運算子（.）**取用物件內的屬性或方法：\n\n```javascript\nconsole.log(person.name) ; // Fei\nperson.say() ; // 'Welcome to my blog!!'\n```\n\n之後我們會更深入探討陣列、函式與物件的關係。\n\n簡言之，物件擁有一組以上的**屬性（Property）**或**方法（Method）**，而屬性和方法也必然符合「鍵值配對」法則。\n\n最後，在進到結論之前，我要先簡單介紹一個很重要的觀念：\n\n在 JavaScript 中，**物件型別（也就是物件這一種值）**的變數賦值或拷貝（Copy）大部分是以**傳參考（by Reference）**的方式實現。\n\n**傳值（By Value）**和**傳參考（By Reference）**是 JavaScript 處理資料的運作邏輯，也是它偷偷不告訴你的事情之一。\n\n<hr>\n\n### 結論\n* 在 JS 中，所有的值（Value）都是純值或物件。\n* JS 內建的資料型別分兩大類，分別是基本型別與物件型別。\n* 基本型別（Primitive）有六種：\n  * 字串（String）\n  * 數字（Number）\n  * 布林值（Boolean）\n  * 空值（Null）\n  * 未定義（Undefined）\n  * 符號（Symbol，ES6 新增的型別）\n* 物件型別（Object）只有一種，就是物件（Object）。\n* 物件型別包含陣列、函式等次型別，它們都屬於特殊的物件。\n* 所以，JS 內建的資料型別總共有 7 種：6 種純值 + 1 種物件。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 3-20\n2. [重新認識 JavaScript: Day 03 變數與資料型別](https://ithelp.ithome.com.tw/articles/10190873)\n3. [重新認識 JavaScript: Day 04 物件、陣列以及型別判斷](https://ithelp.ithome.com.tw/articles/10190962)\n","excerpt":"JavaScript 將資料分為基本型別與物件型別兩類，那麼 JS 內建的資料型別到底有幾種呢？","fields":{"slug":"/weird-JavaScript_10/"},"frontmatter":{"date":"2019-08-10","title":"Wierd JavaScript 10：基本型別（純值）與物件型別","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n資料是程式語言之本，來談談 JavaScript 怎麼處理資料的？\n\n<!-- more -->\n\n### 動態型別（Dynamic Typing）\n\n{% colorquote info %}\nYou don't tell the JavaScript engine what type of data a variable holds. \nIt would figure it out while your code is running.  \n{% endcolorquote %}\n\n\n動態型別指的是，我們不需要特別宣告**變數**的資料型別，JS 引擎執行時，會根據我們所撰寫的程式碼環境，自動判定變數的資料型別，也就是說，**變數的資料型別可以輕易改變**。\n\n基於這種檢查變數型別寬鬆、容許資料型別之間隱性轉換的特性，JavaScript 屬於**弱型別（Weakly Typed）**程式語言。\n\n相對而言，變數型別檢查較為嚴格，且不能任意轉換型別的語言，就屬於**強型別（Strongly Typed）**，譬如 Java 。\n\n~~什麼？你說 JavaScript 屬於 Java 的一種？？？~~\n\n以 Java 為例，我們在宣告變數時，同時會定義該變數的資料型別，就像這樣：\n\n```java\nchar     name   =  'Fei' ; // 定義該變數為字元（Text）\nint      age    =  23    ; // 定義該變數為整數（Integer）\nfloat    BMI    =  22.87 ; // 定義該變數為浮點數（Float）\nboolean  isRich =  false ; // 定義該變數為布林值（Boolean）\n```\n\n在 Java 中，不同的資料型態是不能一起運算處理的，你必須手動幫資料轉型，才能順利執行。\n\n```java\nchar a = '5566' ;\nint  b = 520 ;\nSystem.out.printIn(a + b) ; // error: incompatible types: String cannot be converted to int\nSystem.out.printIn(Integer.parseInt(a) + b) ; // 6086 \n```\n\n相同的程式碼，在 JavaScript 裡面可以順利執行，因為 JS 引擎接受**隱性轉型**，會偷偷幫你轉換資料型別。\n\n```javascript\nvar a = '5566' ;\nvar b = 520 ;\nconsole.log(a + b) ; // 5566520（String） >///////<\n```\n\n仔細觀察 JS 的宣告方式，無論我們用 `var` 、 `let` 還是 `const` 宣告，**都只是在宣告一個變數**，並沒有針對變數型別進行定義。\n\n變數的資料型別要等到 JS 開始執行，**變數被賦值後**，我們才能確定變數的型別。\n\n也就是說，在 JavaScript 中，**變數（Variable）**本身並沒有區分資料型別，變數的資料型別取決於值本身，只有**值（Value）**才有資料型別的區分，分為**原始（Primitive）型別**與**物件（Object）型別**兩大類。\n\n請記得！變數在 JS 中的功用，只是一個**代名詞**，代指某一個**值**或**物件**。\n\n<hr>\n\n### 結論\n* 動態型別指的是，我們不需要特別宣告變數的資料型別，JS 會根據程式碼環境自動判定變數的資料型別。\n* 弱型別指的是，程式引擎（語法解析器）檢查變數型別較為寬鬆、容許資料型別之間隱性轉換。\n* 在 JavaScript 中，變數本身並沒有區分資料型別，值才有區分，分為基礎型別與物件型別兩大類，共七種值。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 3-19\n\n\n\n","excerpt":"資料是程式語言之本，來談談 JavaScript 怎麼處理資料的？","fields":{"slug":"/weird-JavaScript_09/"},"frontmatter":{"date":"2019-08-10","title":"Wierd JavaScript 09：動態型別","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n小飛：「既然範圍鍊能讓函式向外部環境取用變數，那是不是把所有變數都存進全域就好了？」\n\n恰恰相反！實務上，我們會**避免污染全域**，減少全域變數的產生。\n\n<!-- more -->\n\n### 為什麼要避免污染全域？\n\n因為實務上，一支 JavaScript 腳本，也就是 `.js` 檔案，往往會由多位工程師協作撰寫，除此之外，一支 `.html` 檔案也有可能會載入多支 JS 腳本，在這些多人開發的情況下，如果不同開發者不小心在全域環境中使用了相同的變數名稱，那麼後撰寫或後載入的變數，就會覆寫既有變數的值，導致衝突，不易於管理。\n\n所以，實務上我們會避免污染全域環境，減少全域變數的宣告。\n\n小飛：「意思是盡量要把變數宣告進函式裡，成為區域變數囉？」\n\n可以這麼說，我們利用作用域的特性，將變數存進函式區塊中，等到要用的時候再存取。**閉包（Closure）**的原理就是從這個概念出發的。我們之後會談到。\n\n### 作用域（Scope）\n\n{% colorquote info %}\nWhere a variable is **available** in your code.\n{% endcolorquote %}\n\n在 07 篇中我們就已經提過作用域：在函式內宣告的區域變數，只在該函式的執行環境內有效。\n\n換個方式說，詮釋作用域可以詮釋為：**一個變數可以被取用的有效範圍**。\n\n全域變數因為存在全域環境裡，所以能夠被任何函式取用，也就是範圍鍊的最外層。\n\n區域變數因為被宣告在某一函式裡，所以只能夠在**該函式的執行環境內**被取用，當然，也能被該函式內的其他函式取用。\n\n這裡要特別闡述「該函式的執行環境內」，指的是**大括號 `{ ... }` 所框出的範圍**。\n\n所以，我們可以說，**函式是切分變數有效範圍（變數環境、作用域）的最小單位**。\n\n在 **ECMAScript 第六版（俗稱 ES6）**發布以前，我們只能用 `var` 來宣告變數，於是會出現一些弔詭的現象，其中以下面這個範例最為經典：\n\n{% colorquote warning %}\n我希望在五秒內，每一秒就印出一個數字，分別是 0、1、2、3、4 。\n{% endcolorquote %}\n\n\n新手小飛可能會這樣寫：\n\n```javascript\nfor(var i = 0 ; i < 5 ; i++){\n  setTimeout(function(){\n    console.log(i) ;\n  }, 1000) ;\n}\n```\n\n但是他會發現結果不如預期，這段程式碼執行的結果是：**「1 秒後印出五個 5」**。\n\n<font style=\"font-size: 36px\">OMG !! WHY ??</font>\n\n這是因為，當我們在 `for` 迴圈中使用 `var` 來宣告 `i` 時，此時的 **`i` 會被存進全域環境**，成為全域變數。\n\n真的？請接續上面程式碼，執行 `console.log(window.i)` ， JS 會回你 `5`。\n\n這個例子還要結合**非同步回呼**的概念來解釋。還記得嗎？ JS 遇到需要時間處理的非同步事件（函式）時，他會先把它丟進事件佇列，等到執行堆疊為空後才處理。\n\n`for` 跑第一次時， `var` 宣告 `i = 0` ，接著遇到 `setTimeout` ，JS 把 `setTimeout` 丟進事件佇列（因為等待 1 秒需要時間），接著迭代 `i++` 。然後，開始跑第二次 `for` ，由於經過 `var` 宣告的 `i` 是全域變數，此時 `i = 1` 會覆寫既有的 `0` ， 接著遇到 `setTimeout` ，JS 又會把 `setTimeout` 丟進事件佇列...\n\n所以，跑到最後一次，也就是第五次 `for` 結束時， `i = 5` ，全域執行環境也沒東西了，JS 就會回呼執行事件佇列裡面的五個 `setTimeout` ，而此時 `console.log(i)` 裡的 `i` 自然而然等於 `5`，執行的結果就會印出「五個 5」了。\n\n至於為什麼是「1 秒後」？而不是每 1 秒印出一個 5 ？那是因為 JS 執行很快，五個 `setTimeout` **在我們看來**幾乎同時執行。\n\n所以整體執行結果就會是「1 秒後印出五個 5」。\n\n對非同步回呼的概念應該比較熟悉了吧？\n\n回到本篇重點，在這個經典範例中，用 `var` 宣告變數的弔詭現象就是：當我們在 `for` 迴圈中使用 `var` 來宣告 `i` 時，此時的 `i` 會被存進全域環境，成為全域變數。\n\n仔細觀察會發現，`var i = 0` 並不在函式大括號 `{ ... }` 裡面，而是在 `for( ... )` 中，所以 `i` 自然會存進全域環境。\n\n2015 年 ES6 新增的 `let` 宣告，將變數綁定在 `{ ... }` 區塊，更清楚、有效切分作用域和變數環境。\n\n<hr>\n\n### let 與區塊作用域（Block Scope）\n\n簡單來說， `let` 宣告有下列幾個特點：\n\n1. 經過 `let` 宣告的變數，會將該變數環境綁定在其後的 `{ ... }` **區塊作用域**中，包括：\n   * function(){ ... }\n   * for(){ ... }\n   * if(){ ... }\n\n既然如此，我們就可以利用 `let` 改寫上面那一段程式碼，在 `for` 中利用 `let` 宣告 `i` ，將其作用域綁定在後方 `{ ... }` 中，達到我們預期的目的：\n\n```javascript\nfor(let i = 0 ; i < 5 ; i++){\n  setTimeout(function(){\n    console.log(i) ;\n  }, 1000 * i) ;　// 乘上 i 是為了延遲函式執行，得到「每 1 秒後」印出一個數字的效果。\n}\n```\n\n經過 `let` 宣告的 `i` 作用域會被綁在 `{ ... }` 區塊中，當 JS 要把 `setTimeout` 丟進事件佇列時， `console.log(i)` 裡的 `i` 已經能夠取用區塊作用域裡的 `i` ，所以會連同 `i` 的值一起打包丟進事件佇列。等到 JS 最後執行時，就能夠印出  **「0、1、2、3、4」**。\n\n必須特別強調的是，在 `for` 迴圈中，每次跑的區塊都是**獨立的**，也就是說，`for` 第一次跑的 `{ ... }` 和第二次跑的 `{ ... }` 並不一樣，每次經過 `let` 宣告的 `i` ，在電腦的記憶體位置也不一樣，所以才能被 `setTimeout` 取用並打包丟進事件佇列。\n\n其實上面這段範例可以利用**立即執行函式運算式（IIFE）**解構成下面這段程式碼：\n\n```javascript\n// for 跑第一次所建立的 block （執行環境）\n(function(){\n  let i = 0 ;\n  setTimeout(function(){\n    console.log(i) ;\n  }, 1000 * i) ;　\n})() ;\n// for 跑第二次所建立的 block （執行環境）\n(function(){\n  let i = 1 ;\n  setTimeout(function(){\n    console.log(i) ;\n  }, 1000 * i) ;　\n})() ;\n//...\n// for 跑第五次所建立的 block （執行環境）\n(function(){\n  let i = 4 ;\n  setTimeout(function(){\n    console.log(i) ;\n  }, 1000 * i) ;　\n})() ;\n```\n\n2. 經過 `let` 宣告的變數，無論在哪宣告，都不會被存進全域環境，即便宣告在全域中。 \n\n直接用程式碼印證：\n\n```javascript \nlet animal = 'giraffe' ;\nconsole.log(animal) ; // giraffe\nconsole.log(window.animal) ; // undefined（window.animal 找不到任何值）\n```\n\n**雖然不會被存進全域，但可以被參考取用：**\n\n```javascript \nlet animal = 'giraffe' ;\n\nfunction outer(){\n  let perosn = 'Fei' ;\n  console.log(animal) ; // giraffe\n\n  function inner(){\n    console.log(animal) ; // giraffe\n    console.log(perosn) ; // Fei\n  }\n\n  inner() ;\n}\n\nouter() ;\n```\n\n3. 在同個區塊作用域中，只能用 `let` 宣告一次，且宣告後在區塊中可以被覆寫。\n\n```javascript \nlet animal = 'griaffe' ;\n\nfunction test(){\n  let animal = 'tiger' ;\n  console.log(animal) ; // tiger \n  animal = 'lion' ;\n  console.log(animal) ; // lion \n}\n\ntest() ;\nconsole.log(animal) ; // giraffe  \nlet animal = 'panda' ; // Uncaught SyntaxError: Identifier 'animal' has already been declared\nanimal = 'panda' ;\nconsole.log(animal) ; // panda\n```\n\n不同區塊作用域中，當然可以用相同名稱 `let` 宣告變數，因為**區塊不同， `let` 宣告的變數所佔據的記憶體位置就不同**。\n\n4. 經過 `let` 宣告的變數沒有 Hoisting 的特性。\n\n```javascript \nconsole.log(animal) ; // Uncaught ReferenceError: Cannot access 'animal' before initialization\nlet animal = 'griaffe' ; \n```\n\n實務上，現在我們多以 `let` 宣告來取代 `var` ，避免對全域環境的污染。\n\n此外， ES6 還有新增另一種語法 **`const` 常數宣告**，它的特點幾乎與 `let` 相同，唯一不同的是，**經過 `const` 宣告的變數無法被覆寫（具有唯讀性）**，最常被用在賦值 DOM 元素。\n\n<hr>\n\n### 結論\n* 實務上，我們會避免污染全域，減少全域變數的衝突發生。\n* 當今我們多用 `let` 宣告取代 `var` 來避免污染全域。\n  * 經過 `let` 宣告的變數，會將該變數環境綁定在 `{ ... }` 區塊作用域中。\n  * 經過 `let` 宣告的變數，無論你在哪裡宣告，都不會被存進全域環境。\n  * 經過 `let` 宣告的變數沒有 Hoisting 的特性。\n  * 在同個區塊作用域中，只能用 `let` 宣告一次，且宣告後在區塊中可以被覆寫。\n* 總而言之，函式區塊是切分變數環境（也就是變數作用域）的最小單位。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 2-17、2-18\n2. [MDN：let](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/let)\n3. [MDN：const](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/const)\n4. [談談 JavaScript 的 setTimeout 與 setInterval](https://kuro.tw/posts/2019/02/23/%E8%AB%87%E8%AB%87-JavaScript-%E7%9A%84-setTimeout-%E8%88%87-setInterval/)\n5. [你懂 JavaScript 嗎？#12 函式範疇與區塊範疇（Function vs Block Scope）](https://cythilya.github.io/2018/10/19/function-vs-block-scope/)\n\n\n\n","excerpt":"小飛：「既然範圍鍊能讓函式向外部環境取用變數，那是不是把所有變數都存進全域就好了？」 恰恰相反！實務上，我們會避免污染全域，減少全域變數的產生。","fields":{"slug":"/weird-JavaScript_08/"},"frontmatter":{"date":"2019-08-09","title":"Wierd JavaScript 08：作用域、let 與區塊作用域","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n判斷變數屬於**全域變數（Global Variable）**還是**區域變數（Local Variable）**，我們就得看變數宣告所在的位置，也就是變數環境。\n\n<!-- more -->\n\n### 變數環境\n\n{% colorquote warning %}\nWhere the variables live.\n{% endcolorquote  %}\n\n\n變數環境，指的是變數所處的位置。\n\n先前在 weirdJavaScript 03 中，我們得到結論：全域環境，或說全域物件 `window` ，指的是**不在函式裡（Not in a function）**。\n\n也就是說，**在全域執行環境裡出現的變數，無論是否經過 `var` 宣告，都屬於全域變數**。\n\n以這段程式碼為例：\n\n```javascript\nvar a = 100 ; // 經過宣告的 a \nb = 200 ;     // 未經宣告的 b\nvar c = a + b ; // 即便 b 未經宣告，仍可取用。\nconsole.log(a,b,c) ; // 100 200 300 ; a, b, c 都屬於全域變數\n```\n\n那麼區域變數呢？或許你已經猜到了。\n\n**在函式裡經過 `var` 宣告的變數，即屬於（該函式的）區域變數**。\n\n那麼，在函式中**未經 `var` 宣告** 的變數呢？很抱歉，它會被 JS 存進全域，成為**全域變數**。\n\n我們綜合全域變數，來看下面這段程式碼：\n\n```javascript\nvar a = 100 ;  \nb = 200 ; 　　\n\nfunction local(){\n  var m = 555 ;　\n  n = 666 ;\n　\n  console.log(a, b) ; // 100 200　\n  console.log(m, n) ; // 555 666\n}\n\nlocal() ;\n\nconsole.log(a, b, n) ; // 100 200 666 \nconsole.log(m) ; // m is not defined \n```\n\n在上例中，`a` 、 `b` 、 `n` 都屬於全域變數。 `n` 雖然在函式 `local` 中，卻因為未經宣告，而被 JS 存進全域。\n\n既然它們都是全域變數，也就是說，我們能夠在任何執行環境中取用他們。\n\n至於 `m` ，因為它被宣告在函式 `local` 中，屬於函式 `local` 的區域變數，只會存在於函式 `local` 的**執行環境**中，所以我們在全域中讀不到它，它會是 `is not defined`（在全域中未經宣告） 。\n\n因此，為了避免存取上的混淆，實務上，**建議所有變數都要經過 `var` 宣告**。（現在多以 `let` 取代 `var`，請見 08 篇）\n\n綜上所述，我們可以說：**函式是區分變數環境的最小單位**，執行函式所建立的執行環境，就是一個獨立的變數環境。\n\n還記得 06 裡提到的小口訣嗎？**有事件（呼叫函式），就有執行脈絡（執行環境）。**\n\n在函式內宣告的變數，只在該函式的執行環境內有效，當函式執行完畢，該區域變數也就消滅了，這就是變數在函式裡的**作用域（Scope）**。\n\n<hr>\n\n### 範圍鍊（Scope Chain）\n\n小飛：「如果函式執行時，在執行環境中找不到它要取用的值呢？」\n\n如果函式在執行環境中找不到必須取用的變數，**JS 引擎會一層一層向外部環境（Outer Environment）找，直到全域環境（也就是最外層的外部環境）為止**，這就是所謂的**範圍鍊（Scope Chain）**。\n\n什麼意思？直接看下面這段程式碼。\n\n```javascript\nvar name = 'Fei' ;\n\nfunction b(){\n  console.log('My name is ' + name) ; // My name is Fei\n}\n\nfunction a(){\n  var name = 'Bai' ;\n  console.log('My name is ' + name) ; // My name is Bai\n  b() ;\n}\n\na() ;\n```\n\n我們在 function `a` 中宣告 `name = 'Bai'` ， 此時對 JS 而言，這個 `name` 是屬於 function `a` 的區域變數，和開頭第 1 行 `name = 'Fei'` 所宣告的全域變數並不相同（存在電腦記憶體的位置也不同），因此第 9 行 `console.log` 在取用 `name` 時，取用的是區域變數所賦予的值 `'Bai'`，所以會印出 My name is Bai 。\n\n接著， JS 呼叫 function `b` ，並執行第 4 行的 `console.log`，但是因為 function `b` 內部本身沒有宣告 `name` 這個變數，因此， JS 引擎會向 function `b` 的外部環境參考可以取用的變數 `name`，在此例中， function `b` 的外部環境即是全域執行環境，所以第 4 行 `console.log` 取用的會是全域變數 `name` 中的值 `'Fei'`，印出 My name is Fei 。\n\n我們再來看第二個例子。\n\n```javascript\nvar name = 'Fei' ;\n\nfunction a(){  \n  var name = 'Bai' ;\n\n  function b(){\n    console.log('My name is ' + name) ; // My name is Bai\n  }\n  b() ;\n}\n\na() ;\nb() ; // b is not defined\n```\nJS 執行 function `a` 後，先宣告區域變數 `name = 'Bai'`，再宣告 function `b` ，接著執行 function `b` ，但當它要印出第 7 行的 `console.log` 時，卻因為 function `b` 內部本身沒有宣告 `name` 這個變數，因此， JS 引擎會向 function `b` 的外部環境參考可以取用的變數 `name`，在此例中， function `b` 的外部（執行）環境為 function `a` ，所以第 7 行 `console.log` 取用的會是 function `a` 內的區域變數 `name` 的值 `'Bai'`，印出 My name is Bai 。\n\n搭配執行堆疊的概念，我們可以用下面這張圖來解釋。\n\n![執行堆疊、外部環境與範圍鍊參照](scopeChain.JPG)\n\n有感覺了嗎？重點在於，**我們要如何判斷函式所處的外部環境？**\n\n外部（執行）環境指的是**變數或函式所處的詞彙環境（Lexical Environment）**。\n\n詞彙環境！回想一下，我們在 weirdJavaScript 01 說過，詞彙環境指的是：你寫的Code 所處的**物理位置**。\n\n綜合來看，外部環境有下列兩種解釋：\n\n1. **變數或函式被你寫在哪裡？包覆這些 Code 的函式，就是它們的外部（執行）環境。**\n2. **外部（執行）環境，就是創造該函式的執行環境（函式）。**\n\n判斷外部執行環境，有助於我們理解範圍鍊，瞭解函式如何取用、參考變數。\n\n想一想，下面這段程式碼， `console.log` 會是誰？請試著用程式碼的物理位置來判斷。\n\n```javascript\nvar name = 'Fei' ;\n\nfunction a(){\n  function b(){\n    var name = 'Jay' ;\n    c() ;\n  }\n  \n  function c(){\n    console.log('My name is ' + name) ; \n  }\n  name = 'Shiba' ;\n  b() ;\n}\n\na() ;\n```\n<hr>\n\n### 結論\n* 變數環境指的是變數所處的位置。\n* 在全域執行環境裡出現的變數，無論是否經過宣告 `var` ，都屬於全域變數。\n* 在函式裡經過 `var` 宣告的變數，屬於該函式的區域變數。\n* 在函式裡**未經** `var` 宣告的變數，會被存進全域變數。\n* 函式是區分變數環境的最小單位。\n* 作用域指的是：在函式內宣告的區域變數，只在該函式的執行環境內有效。\n* 範圍鍊指的是：JS 引擎會一層層向外部環境參照可取用的變數，直到全域環境為止。\n* 外部（執行）環境指的是變數或函式所處的詞彙環境。\n\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 2-15、2-16\n\n\n\n\n","excerpt":"判斷變數屬於全域變數（Global Variable）還是區域變數（Local Variable），我們就得看變數宣告所在的位置，也就是變數環境。","fields":{"slug":"/weird-JavaScript_07/"},"frontmatter":{"date":"2019-08-08","title":"Wierd JavaScript 07：變數環境與範圍鍊","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n每當我們呼叫一個函式，JS 會立即建立屬於該函式的執行環境，然後堆起來（？）\n\n<!-- more -->\n\n### 呼叫（Invocation）\n\n{% colorquote info %}\nRunning a function\n{% endcolorquote %}\n\n\n在 JS 中，我們以 `函式名稱` 加上一對 `()` ，來呼叫（Invoke）函式，也就是**執行**該函式的意思。\n\n每當我們呼叫一個函式時，JS 會立即**建立屬於該函式的執行環境（Execution Context），並執行該函式**。\n\n所以，我們可以得出一個小口訣：**有事件（函式），就有執行脈絡（執行環境）。**\n\n以下面這段程式碼為例，駐記說明 JavaScript 引擎做了哪些事情。\n\n```javascript\n// 建立 Global Execution Context\n// Creation & Hoisting : 宣告 function b\n// Creation & Hoisting : 宣告 function a\nfunction b(){\n  console.log('Run function b.') ;　// 印出 Run function b.\n  // function b 結束，消滅 function a 的執行環境，並回到 function a。\n}\n\nfunction a(){\n  b() ; // 建立 function b 的執行環境，執行 function b。\n  // function a 結束，消滅 function a 的執行環境，並回到 Global Execution Context。\n}\n\na() ; // 建立 function a 的執行環境，執行 function a 。\n\n// 消滅 Global Execution Context\n```\n<hr>\n\n###  執行堆疊（Execution Stacks）\n\n從上面的程式碼範例，我們可以歸納出 JS 建立執行環境的流程（順序）大致如下：\n\n> **Global** Execution Context → **function a** Execution Context → **function b** Execution Context\n\n建立執行環境的順序，我們可以用下面這張圖來想像：\n\n![執行堆疊](./executionStacks.JPG)\n\n如同圖，所謂執行堆疊，意思是 JS 所建立的執行環境，會一層一層往上疊加，堆在最上方的執行環境，即**正在執行的事件（函式）**。\n\n反過來看，從上面的程式碼範例，我們同樣可以歸納出 JS 消滅執行環境的流程（順序）：\n\n{% colorquote info %}\n**function b** Execution Context → **function a** Execution Context → **Global** Execution Context  \n{% endcolorquote %}\n\n\n當一個個事件（函式）完成後，JS 消滅執行環境的順序，也會一層一層往下移除，直到執行堆疊為空。\n\n啊！順帶一提，還記得我上回說過：當執行堆疊為空， JS 會做什麼呢？\n\n{% colorquote success %}\n對，檢視事件佇列是否有待回呼事件，若有就依序執行。\n{% endcolorquote %}\n\n回到執行堆疊本身，我認為它是用來幫助我們理解 **JS 引擎執行函式順序**的概念，也就是說，它並不是真的存在於 JS 裡的一個系統，也不是一個範圍，只是我們想像出來的概念而已。\n\n此外，我也覺得，用「堆疊」這個詞來描繪並不精確，如果用「深度」來形容似乎貼切多了，因為我們在全域中呼叫函式，在函式中呼叫另一個函式，相互呼叫，呼叫得愈多，執行深度也愈深。\n\n這段只是我的小MurMur，往後還是會以執行堆疊來描述 JS 執行函式順序的概念。\n\n<hr>\n\n### 結論\n* 在 JavaScript 中，呼叫函式等於執行函式。\n* 每呼叫一個函式，JS 會即刻建立屬於該函式的執行環境，並執行該函式。\n* 執行堆疊的意思是， JS 所建立的執行環境會一層一層往上堆疊，堆在最上方的執行環境，就是正在執行的函式。\n* 執行堆疊的概念用來幫助我們瞭解 JS 引擎執行函式的順序。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 2-14\n\n\n\n\n","excerpt":"每當我們呼叫一個函式，JS 會立即建立屬於該函式的執行環境，然後堆起來（？）","fields":{"slug":"/weird-JavaScript_06/"},"frontmatter":{"date":"2019-08-07","title":"Wierd JavaScript 06：呼叫函式、執行堆疊","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\nJavaScript **本身**是一門**單執行緒**且**同步執行**的高階程式語言。\n\n<!-- more -->\n\n### 單執行緒（Single Threaded）\n{% colorquote info %}\n**One command at a time.**\n{% endcolorquote %}\n\n單執行緒的意思是， JavaScript 一次**只能做一件事情**（一行指令）。\n\n<hr>\n\n### 同步執行（Synchronous Execution）\n{% colorquote info %}\n**One at a time and in order.**\n{% endcolorquote %}\n\n同步執行的意思是， JavaScript 一次只能做一件事情，這件做完，才能做下一件，**按照順序一件接著一件**（逐行執行命令）。\n\n小飛：「可是我聽過 JavaScript 有一個特色叫做 **非同步（Asynchronous）**耶？」\n\n好，既然你誠心誠意發問了，我就...\n\n<hr>\n\n### 非同步（Asynchronous）\n\n{% colorquote info %}\n**More than one at a time.**\n{% endcolorquote %}\n\n非同步的意思是，「同時間可以做不只一件事」。\n\n注意！我說的**不是** JavaScript。再次強調，**JS 引擎是同步執行的**，一次只能做一件事且按照指令順序。\n\n那為什麼非同步會是 JavaScript 的特色呢？那是因為**JavaScript 引擎可以和瀏覽器內其他引擎溝通，互相合作**。\n\n事實上，瀏覽器裡不只包含 JS 引擎，也包含負責畫面呈現的**渲染引擎（Rendering Engine）**、獲取伺服器資料的 **請求方法（HTTP Request Methods）** 等等。\n\n而 JavaScript 引擎內有個東西叫作**事件佇列（Event Queue）**，**JS 會把需要和其他引擎合作的事件，暫時放在事件佇列裡等待處理**。\n\n這裡可以用兩個例子來說明。\n\n### 例1. JS 與 Rendering Engine 合作的非同步事件\n\n當我們在 JavaScript 中監聽一則 `click` 事件，因為它需要使用者點擊滑鼠來觸發事件，所以 JS 會把這個事件暫時放進事件佇列中，**等到 JS 逐行跑完（全域執行環境的）指令，也就是執行堆疊（Execution Stack）為空以後**，再來執行這則 `click` 事件（事件觸發後由 Rendering Engine 渲染畫面）。譬如下面這段程式碼：\n\n```javascript\n// 全域執行開始\nconsole.log('start execution (time countdown starts)') \nfunction waitFiveSeconds(){\n  var endTime = 5000 + new Date().getTime() ;\n  while(new Date() < endTime){}　// 5 秒內不會做任何事，此時點擊網頁，click 事件不會立刻被執行，而是被放進事件佇列等待。\n  console.log('finished function (5 seconds passed)') ;　\n  // 函式 waitFiveSeconds 結束（結束 waitFiveSeconds 執行堆疊）\n}\n\nfunction clickHandler(){　// 宣告　click 事件（函式）\n  console.log('click event !') ;\n}\n\ndocument.addEventListener('click',clickHandler) ; // 註冊 click 事件\n\nwaitFiveSeconds() ; // 執行函式 waitFiveSeconds （建立 waitFiveSeconds 執行堆疊）\nconsole.log('finished execution') ;　\n// 全域執行結束，開始執行事件佇列的事件（執行 clickHandler -> 印出 'click event !' -> 結束 clickHandler）。\n// 持續檢查事件佇列，若有新的事件觸發（被丟進佇列），便立即執行。\n```\n\n執行結果如下：\n\n```\nstart execution (time countdown starts)\nfinished function (5 seconds passed)\nfinished execution\nclick event !　// 你點擊網頁（觸發 click）多少次，這裡就會有多少個 click event !\n```\n\n### 例2. JS 與 HTTP Request 合作的非同步事件\n\n當我們在 JavaScript 中利用 HTTP Request 向伺服器發出一則資料請求，由於等待回覆（Response）必然耗時，所以 JS 會把這個請求（Request）暫時放進事件佇列中**等待回覆**（請求已經發出，並由 HTTP Request Methods 執行），**等到 JS 逐行跑完（全域執行環境的）指令，也就是執行堆疊（Execution Stack）為空以後**，再來處理伺服器 Response 的資料。\n\n![JS 會優先處理腳本中的執行堆疊，最後才執行事件佇列。（圖片源自參考資料 1.）](./eventQueue.JPG)\n<center>JS 會優先處理腳本中的執行堆疊，最後才執行事件佇列。</center>\n\n我們可以把事件佇列想像成 JS 引擎的對外窗口，每當 JS 遇到需要和其他引擎合作的事件，會將這些事件依序放進事件佇列，先專心跑完全域執行環境的程式碼後，再回頭逐一執行事件佇列裡的任務。\n\n你也可以把事件佇列想像成一個大函式，把需要**非同步執行**的事件都先放進去，爾後再拿出來執行。這樣的方式，就是所謂的**非同步回呼（Asynchronous Callback）**。而那些**JS 需要和其他引擎合作的事件（函式）**，或說，這些**被 JS 放進事件佇列裡的事件（函式）**，正是一種**回呼函式（Callback Function）**。\n\n用生活化的方式解釋回呼，大概就像這個情境：白白（JS）一次只能做一件事，他現在正在和客戶A講電話，突然客戶B來電，白白就寫了張MEMO（事件佇列）：「客戶A談完要打給客戶B」。下一秒客戶C又來電，於是白白又寫下：「B客戶談完後要打給C」。~~然後就得加班了？~~\n\n關於回呼的概念我們之後有機會再細談，回到事件佇列上。\n\n當事件佇列裡排定的事件都處理完後，JS 也不會閒著，它會**持續檢查（Continuous Check）**事件佇列有沒有新的事件進來，如果有的話，就會立即處理，如 ※例1. 的程式碼。\n\n發現了嗎？ JavaScript 這樣的執行流程，依然是**同步**的：一次只做一件事，這個做完再做下一個，按順序執行。\n\n總而言之，JavaScript 本身雖然是**同步**的，但因為它能夠利用事件佇列與瀏覽器中的其他引擎互相溝通、分工合作，達到**非同步**的效果，非同步也就成為了 JS 的特色。\n\n最後，需要特別注意的是，**JS 非同步的部分，發生在 JS 引擎之外**，也就是其他協作引擎所執行的。\n\n<hr>\n\n### 結論\n* JavaScript 本身是一門單執行緒且同步執行的高階程式語言，意思是，它一次只能做一件事情，而且必須按順序執行，執行完一件才能繼續做下一件。\n* JavaScript 能夠利用事件佇列與瀏覽器中的其他引擎互相溝通、分工合作，利用同步達到非同步的效果，使得非同步成為 JS 的特色。\n\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 2-13、2-18\n2. [先來看看瀏覽器內核長怎樣吧！](https://ithelp.ithome.com.tw/articles/10191427)\n3. [MDN：Callback function](https://developer.mozilla.org/en-US/docs/Glossary/Callback_function)\n","excerpt":"JavaScript 本身是一門單執行緒且同步執行的高階程式語言。","fields":{"slug":"/weird-JavaScript_05/"},"frontmatter":{"date":"2019-08-06","title":"Wierd JavaScript 05：單執行緒、同步執行、非同步回呼","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n我們之前提過： JavaScript 的執行環境**不只包含你寫的 Code**，因為它必須經過編譯器轉換。\n\n所以，JavaScript 的執行脈絡到底包含哪些事情是我們不知道的？\n\n其中，最重要的就是 **Creation** 與 **Hoisting** 。\n\n<!-- more -->\n\n事實上，在你寫的 JavaScript 被執行之前，編譯器會**先偷偷幫你**做好兩件事情：\n\n1. 創造階段（Creation）\n2. 提升階段（Hoisting）\n\n<hr>\n\n### Creation（創造）\n\n首先， Creation 階段指的是**建立全域執行環境**、**this**以及**最外部環境**。\n\n在上一篇中我們有說明，在環域環境中：`全域執行環境 = this = 外部環境`。\n\n### Hoisting（提升）\n\nCreation 階段後接著進行 Hoisting 階段：**JavaScript 引擎會先幫你宣告 `變數` 與 `函式`** ，其中，**變數會先被定義為 `undefined`** ，等到執行時才會真正賦值。\n\n直接看程式碼比較好理解：\n\n```javascript\nvar a = 'Variable would be hoisted in JS.' ;\nfunction b(){\n  console.log('Function would be hoisted in JS.') ;\n}\n\nconsole.log(a) ;\nb() ;\n```\n\n上面這段程式碼執行後會依序出現：\n\n```\nVariable would be hoisted in JS.\nFunction would be hoisted in JS.\n```\n\n這個結果很直觀，但如果我們稍微調動一下程式碼順序：\n\n```javascript\nconsole.log(a) ;\nb() ;\n\nvar a = 'Variable would be hoisted in JS.' ;\nfunction b(){\n  console.log('Function would be hoisted in JS.') ;\n}\n```\n\n此時，執行結果會依序出現：\n\n```\nundefined\nFunction would be hoisted in JS.\n```\n\n<font style=\"font-size: 36px\">OMG !! WHY ???</font>\n\n為什麼此時 `a` 變成 `undefined` ，而 function `b` 依然可以執行？\n\n因為，在 JavaScript 編譯器眼中，這段程式碼其實長這樣：\n\n```javascript\n// var = a ;  JS 偷偷先幫我們宣告變數 a 為 undefined，但它不會告訴我們，所以我們看不到這段。（第 1 行）\n// JS 偷偷先幫我們宣告函式，但它不會告訴我們，所以我們看不到這段。（第 2 ~ 5 行）\n// function b(){\n//  console.log('Function would be hoisted in JS.') ;\n//} \n\nconsole.log(a) ; // undefined \nb() ; // Function would be hoisted in JS.\n\na = 'Variable would be hoisted in JS.' ;\nfunction b(){\n  console.log('Function would be hoisted in JS.') ;\n}\n```\n\nJS 編譯器會先宣告全域執行環境裡的 Variables 與 Functions ，並儲存進電腦的記憶體中，供後續執行使用。**先宣告變數與函式並存進電腦記憶體這個動作，就是 Hoisting**。\n\n不少網路上對 Hoisting 的解釋是：編譯器會將變數宣告與函式宣告「挪移」到最上方。但是。這樣的說法並不正確。\n\n更精確的說法是：JS 引擎在執行程式碼前，會**先將整個（JS檔案裡的）程式碼掃過一遍**，並且**只抓變數宣告和函式宣告**出來，逐一存入電腦記憶體，供後續真正執行時使用。\n\n比喻成實際狀況，就像是：小飛今天想做提拉米蘇，他得先看一次食譜（JS檔案），需要準備哪些材料（變數）？有什麼方法（函式）？腦中有個概念（存進記憶體）後，才真正開始照著食譜動手做。\n\n所以，**實際上 Code 的位置並沒有改變**，只是 JS 編譯器進行 Hoisting 後，讓我們以為程式碼位置有所變動。如上面那一段程式碼呈現的。\n\n特別要注意的是，JS 編譯器只會對**變數宣告**與**函式宣告（Function Declaration）**進行 Hoisting ，如果是以函式表達式（Function Expressions）將函式賦予變數，那麼就必須等到 JS 真正開始執行後才能呼叫該函式。如下面這段程式碼：\n\n```javascript\nconsole.log(funcDeclaration) ; // undefined\nconsole.log(funcExpressions) ; // undefined\nfuncExpressions() ; // undefined is not a function \n\nfunction funcDeclaration(){\n  console.log('Function Declaration would be hoisted in JS.') ;\n}\nvar funcExpressions = function(){\n  console.log('Function Expressions can not be hoisted in JS.')\n}\n\nfuncDeclaration() ; // Function Declaration would be hoisted in JS.\nfuncExpressions() ; // Function Expressions can not be hoisted in JS.\nconsole.log(funcExpressions) ; // ƒ (){ console.log(...) }\n```\n\n<hr>\n\n### undefined\n\nJS 編譯器進行 Hoisting 時，**如果該變數還沒有被賦予值（Value）就直接被取用，JS 就會先賦予該變數 `undefined` 這個值**。也就是前面所舉例的這段程式碼：\n\n```javascript\nconsole.log(a) ; // a 尚未被賦予值就被 console.log()，所以 JS 先賦予 a 為 undefined 值\nb() ;\n\nvar a = 'Variable would be hoisted in JS.' ;　// a 被賦予一個字串 'Variable would be hoisted in JS.'\nfunction b(){\n  console.log('Function would be hoisted in JS.') ;\n}\n\nconsole.log(a) ; // Variable would be hoisted in JS.\n```\n\n之前我們曾經介紹過， `undefined` 屬於 JS 六種基本型別中的一種「值」（Value），意思是：**「該變數存在於 JS 中，且已經被宣告，但尚未被賦予值」**。儘管如此， `undefined` 本身還是一種值...我真搞不懂 JS 呀！\n\n要注意的是，如果某變數**連宣告都還沒宣告過**，那麼 JS 會判定該變數為 `is not defined`，意思是：**「該變數不存在於 JS 中（因為你沒有宣告過它）」**。 \n\n用程式碼比較如下：\n\n```javascript\nconsole.log(a) ; // undefined\nconsole.log(b) ; // b is not defined\n\nvar a = 100 ;\n\nconsole.log(a) ; // 100\n```\n\n另一個容易與 `undefined` 搞混的值，叫做 `null`，這裡簡單區別兩者。\n\n`null` 也是 JS 六種基本型別的一種「值」，它的意義是：**「空值」，代表這個變數已經宣告，且可能曾經有值，但現在沒有**。\n\n**小飛：「那 `null` 等於 `0` 嗎？」**\n\n你可以試試看這段程式碼：\n\n```javascript\nvar a = null ;\nconsole.log(a == 0) ;　 // false \nconsole.log(a >= 0) ;　 // true .... ˊ<_ˋ????????\n```\n\n關於 `null` 的詳細介紹與型別比較，就等之後有機會再談囉！\n\n<hr>\n\n### 結論\n* 創造提升（Creation & Hoisting）指的是：在 JS 真正執行你寫的 Code 之前， JS 引擎會先跑過整個全域執行環境，並將 `變數宣告` 與 `函式宣告` 抓出來存進電腦記憶體，供後續真正執行時使用。\n* `undefined` 屬於 JS 基本型別的其中一種「值」（Value），意思是：「該變數存在於 JS 中，且已經被宣告，但尚未被賦予值」。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 2-10 、 2-11\n2. [MDN：Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)\n\n\n\n\n\n\n","excerpt":"我們之前提過： JavaScript 的執行環境不只包含你寫的 Code，因為它必須經過編譯器轉換。 所以，JavaScript 的執行脈絡到底包含哪些事情是我們不知道的？ 其中，最重要的就是 Creation 與 Hoisting 。","fields":{"slug":"/weird-JavaScript_04/"},"frontmatter":{"date":"2019-08-06","title":"Wierd JavaScript 04：創造、提升與 undefined","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n還記得之前提到的**執行脈絡／環境（Execution Context）**嗎？ \n\n<!-- more -->\n\n### 全域環境\n\nJavaScript 的全域（Global）環境，指的就是 **（最）外部執行環境（Outer Environment）**，也是語法解析器解析 JavaScript 程式碼的地方，換句話說，你所寫的程式碼如果不在函式裡，那必然在**函式外（Not in a function），即全域環境**。\n\n而全域的意思是，**在全域環境所儲存的變數或函式，在其下任一（子）執行環境，都能夠直接取用那些全域變數或函式**。譬如下面這段程式碼，在 function `show` 中，能夠抓到全域環境中宣告的變數 `a` 。\n\n```javascript\nvar a = 'Hello JavaScript!!' ;\n\nfunction show(){\n  console.log(a) ; // 'Hello JavaScript!!'\n}\n\nshow() ;\n```\n\n在全域環境下，JavaScript 引擎會自動幫我們產生兩樣東西：\n1. 全域物件（Global Object）\n2. 變數 `this`\n\n![Window 與 this](./window.JPG) \n\n如上圖，我們在 Google Chrome Dev Tool 中分別輸入 `window` 和 `this` ，會發現在全域環境下，**`this` 同樣指向 `window` 這個全域物件**。\n\n全域物件在不同的程式語言中有不同名稱，在瀏覽器（JavaScript 檔案）裡即是 `window` ，它已經儲存一些基本的函式（Function）和方法（Method）供我們使用，當然，我們也可以儲存變數在 `window` 這個**全域物件**裡面，這些被存在全域環境中的變數，就是俗稱的**全域變數（Global Variable）**。\n\n譬如下面這段程式碼：\n\n```javascript\nvar a = 'Hello JavaScript!!' ;\nvar b = function foo(){return 100} ;\n\nconsole.log(a, b) ; // 'Hello JavaScript!!' ƒ foo(){return 100};\nconsole.log(window.a, window.b) ; // 'Hello JavaScript!!' ƒ foo(){return 100};\n```\n\n既然全域物件命名為 `window` （視窗），就表示：每一個網頁（視窗）都是一個（全域）執行環境，互相獨立，互不干擾。\n\n<hr>\n\n### 結論\n\n最後，可以用課程內這張圖來總結：\n\n![在全域環境中：Global = window = this（圖片源自參考資料 1.）](./global.JPG) \n\n* 全域環境是 JS 最外層的執行環境（Outer Environment），它等於全域物件 `window` 。\n* 全域環境，或說全域物件 `window` ，即：不在函式裡（Not in a function）。\n* 在全域環境中，變數 `this` 等於全域物件 `window` 。\n* 每一個網頁（視窗）都是一個 `window` ，互相獨立。\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 2-9\n","excerpt":"還記得之前提到的執行脈絡／環境（Execution Context）嗎？","fields":{"slug":"/weird-JavaScript_03/"},"frontmatter":{"date":"2019-08-05","title":"Wierd JavaScript 03：全域環境與全域物件","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\nName/Value Pair？ Key/Value Pair？沒差啦！反正就得成雙成對。\n\n<!-- more -->\n\n### 名稱／數值配對（Name/Value Pair）\n\n{% colorquote info %}\n**A Name which maps to a unique value**.\nThe name may be fedined more than one, but **only can have one value in any given context**.\n{% endcolorquote %}\n\n**在執行環境中，只能存在一個名稱（Name），且該名稱只會對應到一個定義的數值（Value）**，即所謂的 Name/Value Pair，也有人稱為「鍵值配對」Key/Value Pair，類似 `Python` 中的「字典」（Dictionary）結構。\n\n基本的 Name/Value Pair 就像這樣：\n\n```javascript\npersonName = 'Marisa' ;\n```\n\n{% colorquote info %}\nThat value may be more name/value pair.\n{% endcolorquote %}\n\n但實際上， value 可以是更多 Name/Value Pairs 的集合：\n\n ```javascript\npeopleName = {\n  DavidFamily: 'David',\n  LisaFamily: {\n    father: 'Ryan'.\n    mother: 'Ann',\n    dog: 'Murffy'\n    }\n  } ;\n```\n\n<hr>\n\n### 物件（Object）\n\n{% colorquote info %}\nA collection of name/value pairs.\n{% endcolorquote %}\n\n在 JavaScript 中，物件最簡單的定義就是，**物件（Object）是一群 ame/value pairs 的集合**。\n\n我們用左右大括號 `{}` 來表示物件，一個基本的物件長這樣：\n\n ```javascript\nTaipei = {\n  Districts: 12,\n  MetroLines: 5,\n  touristSpot: 'Taipei 101'\n}\n```\n\n因為 Name/Value Pair 中的 Value 也可以是另一組  Name/Value Pairs ，所以物件也可以是：\n\n ```javascript\nTaipei = {\n  Districts: 12,\n  MetroLines: 5,\n  touristSpot: {\n    mustGo : 'Taipei 101',　\n    mustEat : ['Ding-Tai-Fung', 'bubble tea'] // Value 也可以是陣列（Array），因為陣列也屬於物件的一種。\n  }\n}\n```\n在上面這個範例中，最外層的 `Taipei` 是一個物件，內層的 `touristSpot` 也是一個物件。因為**物件就是鍵值配對（Name/Value Pair）的集合**。\n\n![物件就是 Name/Value Pairs 的集合（圖片源自參考資料 1.）](./nameValuePairs.JPG)\n\n更精確地說，在 JavaScript 中，資料型別分為兩類：\n1. 基本型別／原始型別（Primitive）\n  * 字串（String）\n  * 數字（Number）\n  * 布林值（Boolean）\n  * 空值（Null）\n  * 未定義（Undefined）\n  * Symbol（ES6 新增的型別）\n2. 物件型別（Object）\n  * 物件（Object）\n    * 陣列物件（Array）\n    * 函式物件（Function）\n\n關於資料型別的詳細解釋，我們之後會提到。\n\n<hr>\n\n### 結論\n\n* 名稱／數值配對（鍵值配對）指的是，在一執行環境中，一個名稱只能對應到一個值，且值可能是另一個物件（鍵值配對的集合）。\n* 物件指的是**鍵值配對的集合**。\n* **在 JavaScript 中，任何一筆資料，如果不是基本型別（值），就是物件型別。**\n\n### 參考資料\n1. JavaScript 全攻略：克服 JS 奇怪的部分 2-7\n2. [MDN：JavaScript data types and data structures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures)\n\n","excerpt":"Name/Value Pair？ Key/Value Pair？沒差啦！反正就得成雙成對。","fields":{"slug":"/weird-JavaScript_02/"},"frontmatter":{"date":"2019-08-05","title":"Wierd JavaScript 02：Name / Value Pair 與物件","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}},{"node":{"rawMarkdownBody":"\n相信你看完這篇就不會想學 JavaScript 了。\n\n<!-- more -->\n\n## 語法解析器（Syntax Parsers）\n---\n\n\n> A program that **reads your code** and **determines what it does** and **if its grammar is valid**.\n\n語法解析器，或稱「編譯器／直譯器」（Compiler／Interpreter），會將我們所寫的程式碼轉換成電腦（硬體）能夠接收的指令。\n\n在 JavaScript 中，語法解析器會一字一句的解析我們所寫的程式碼，並決定程式碼是否有效，或是語法上有沒有出錯。\n\n例如 `function say() {...}` 這段程式碼，語法解析器會逐字解析為：\n\n**f-u-n-c-t-i-o-n-空格-s-a-y-(-是否有代入參數-)-{-函式區塊內容-}** \n\n\n語法解析器會對照該段程式碼與該程式語言所規範的語法結構： `function 名稱(參數) {函式內容}` ，如果都沒有語法上的錯誤，即決定這段程式碼為一個有效的**函式（function）**。\n\n如果語法有誤（拼錯、漏字、順序不對等等），即會出現常見的 `SyntaxError` 。\n\n**JavaScript 不是一種程式語言嗎？為什麼還需要 Syntax Parser 去解析成電腦才懂的語言？**\n因為不是所有程式語言都是電腦懂的指令碼，就 JavaScript 而言，它是屬於高階程式語言（High-level language）的一種（其他如 C 、 Java 等等），需要經由編譯器（Compiler）將其原始碼轉換成電腦可以解讀、執行的低階機器語言，即目標語言（機器碼 Machine Code）。\n\n\n小結：\n1. Syntax Parsers 是一個中介轉譯器，協助我們（寫的程式碼）與電腦（韌體）溝通，\n2. 電腦（韌體）接收到的指令，其實不完全是我們寫的程式碼，而是經過 Syntax Parsers 轉譯過的指令。\n\n![Syntax Parsrer是我們與電腦之間的中介溝通者（圖片源自參考資料 1.）](./syntaxParser.JPG)\n\n## 詞彙環境（Lexical Environments）\n---\n\n> Where something sits physically in **the code you write**.\n\n簡單來說，詞彙環境指的是**你的（某一段） Code 寫在哪裡？附近有哪些 Code ？**。\n\n**程式碼的位置，決定了語法解析器如何解析你所寫的程式碼**，這在 JavaScript 中尤其重要，很多**JavaScript 奇怪的部分**就是因為 lexical 的緣故，這在我們後面提到變數環境、函式作用域與範圍鏈（Scope Chain）時就能深刻體會到箇中奧妙。\n\n有時候我們寫的程式碼執行結果與期待不符，往往就是因為寫錯 **Code 的位置（lexical）**。更直白地說，我們**不夠熟悉程式語言（JavaScript）解析語法的邏輯和規範**。\n\n譬如下面這段程式碼：\n\n```javascript:title=example-file.js\nvar a = 100 ; var b = 100 ;\nconsole.log(a++,++b) // 結果會出現什麼？\nconsole.log(a,b) // 那這個結果會出現什麼？\n\n// 我猜你現在心裡 OS：What the ... ?????\n```\n\n小結：\n* 你的（某一段） Code 寫在哪裡很重要！\n* 你的（某一段） Code 寫在哪裡很重要！！\n* 你的（某一段） Code 寫在哪裡很重要！！！\n* 可以說，學習一門程式語言，最核心技術面關鍵便是**掌握該語言的語法結構**。\n\n## 執行脈絡（Execution Contexts）\n---\n\n> **A wrapper** to **help** manage **the code** that is **running**.\n\n講到脈絡（context），這個詞，~~就得提到歷史社會學（Historical sociology）~~，它最常被用來代指「（一個事件的）來龍去脈」：什麼先發生？什麼接著發生？發生的時候，客觀環境是怎麼樣？諸如此類，譬如「社會脈絡」、「歷史脈絡」等詞。\n\n用這樣的語義去思考，程式語言中的執行脈絡（又稱「執行環境」）指的是，**正在執行的 Code 所處的脈絡（上下文）為何？前面有哪些 Code ？後面接了哪些 Code ？被什麼 Code 所包覆（wrapped）？**。\n\n表面上，執行脈絡包含你所寫的、正在執行的程式碼，但，其實，**它不只包含你寫的 Code** ，還包含處理其他事情（do other things），因為你的 Code 事實上會經過編譯器轉換，而編譯器轉換的方式不盡然只執行你寫的 Code 。（傲嬌的編譯器？）\n\n簡單理解 JavaScript 的執行脈絡，可以舉這個例子：在函式（function）中宣告變數（Variable）。\n```javascript\nfunction testA(){\n  var a = 100 ;\n  console.log(a) ; // 這裡的 a 是多少？\n  testB() ;\n} \n\nfunction testB(){\n  var a = 200 ;\n  console.log(a) ; // 這裡的 a 又是多少？\n}\n\nvar a ;\ntestA() ;\nconsole.log(a) ; // 那這裡的 a 呢？\n\n// 上述程式碼執行後的結果， a 值印出順序為何？\n```\n\n## 結論\n---\n\n* 語法解析器：我們所寫的 JavaScript 必須經由語法解析器轉換成電腦（韌體）理解的語言，所以，語義很重要！\n* 詞彙環境：Code 寫的位置（語法結構）很重要！\n* 執行脈絡：目前執行的 Code 所處的環境／上下文是什麼？\n\n## 參考資料\n---\n1. JavaScript 全攻略：克服 JS 奇怪的部分 2-6\n\n\n\n\n\n","excerpt":"相信你看完這篇就不會想學 JavaScript 了。","fields":{"slug":"/weird-JavaScript_01/"},"frontmatter":{"date":"2019-08-04","title":"Wierd JavaScript 01：語法解析、詞彙環境、執行脈絡","tags":["JavaScript","Wierd JavaScript"],"update":"0001-01-01"}}}]}},"pageContext":{}},"staticQueryHashes":["2027115977"]}
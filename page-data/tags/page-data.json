{"componentChunkName":"component---src-pages-tags-tsx","path":"/tags/","result":{"data":{"allMarkdownRemark":{"group":[{"fieldValue":"Wierd JavaScript","totalCount":40,"edges":[{"node":{"excerpt":"欸！ JavaScript 裡面的所有東西都是物件！","fields":{"slug":"/weird-JavaScript_40/"},"frontmatter":{"date":"2019-09-09","update":"0001-01-01","title":"Wierd JavaScript - 40：所有東西都是物件（或純值）","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"來瞭解原型吧！","fields":{"slug":"/weird-JavaScript_39/"},"frontmatter":{"date":"2019-09-08","update":"0001-01-01","title":"Wierd JavaScript - 39：原型與原型鍊","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"與其他程式語言不同，JavaScript 採用原型繼承的方式，將所有物件串聯起來！","fields":{"slug":"/weird-JavaScript_38/"},"frontmatter":{"date":"2019-09-07","update":"0001-01-01","title":"Wierd JavaScript - 38：古典繼承 v.s. 原型繼承","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"透過資源庫培養函式程式設計的思維！","fields":{"slug":"/weird-JavaScript_37/"},"frontmatter":{"date":"2019-09-05","update":"0001-01-01","title":"Wierd JavaScript - 37：函式程式設計（二）","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"邁向進階 JavaScript ：函式程式設計（Functional Programming）","fields":{"slug":"/weird-JavaScript_36/"},"frontmatter":{"date":"2019-09-04","update":"0001-01-01","title":"Wierd JavaScript - 36：函式程式設計（一）","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"call() 、 apply() 、 bind() 都屬於函式的方法，可以用來改變函式中 this 代指的對象。","fields":{"slug":"/weird-JavaScript_35/"},"frontmatter":{"date":"2019-08-31","update":"0001-01-01","title":"Wierd JavaScript - 35：call()、apply()、bind()","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"如果你曾經使用過 jQuery 、  等 Callback Function，其實你已經使用過閉包的概念了。","fields":{"slug":"/weird-JavaScript_34/"},"frontmatter":{"date":"2019-08-29","update":"0001-01-01","title":"Wierd JavaScript - 34：閉包與回呼","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"透過閉包的原理，搭建一座座函式工廠吧！","fields":{"slug":"/weird-JavaScript_33/"},"frontmatter":{"date":"2019-08-27","update":"0001-01-01","title":"Wierd JavaScript - 33：函式工廠","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"這題沒答對，你敢說你懂閉包？","fields":{"slug":"/weird-JavaScript_32/"},"frontmatter":{"date":"2019-08-26","update":"0001-01-01","title":"Wierd JavaScript - 32：閉包（2）","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"學了這麼多，現在我們來嘗試理解 JS 小魔王：閉包。","fields":{"slug":"/weird-JavaScript_31/"},"frontmatter":{"date":"2019-08-25","update":"0001-01-01","title":"Wierd JavaScript - 31：閉包（1）","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"什麼情況下會用到 IIFEs ？","fields":{"slug":"/weird-JavaScript_30/"},"frontmatter":{"date":"2019-08-24","update":"0001-01-01","title":"Wierd JavaScript - 30：IIFEs 與安全程式碼","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"有一種函式，我們用完就丟。","fields":{"slug":"/weird-JavaScript_29/"},"frontmatter":{"date":"2019-08-23","update":"0001-01-01","title":"Wierd JavaScript - 29：立即呼叫函式表達式（IIFEs）","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"在 JavaScript 中，怎麼使用空格，是門藝術。","fields":{"slug":"/weird-JavaScript_28/"},"frontmatter":{"date":"2019-08-21","update":"0001-01-01","title":"Wierd JavaScript - 28：空格","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"JavaScript 的語法解析器會自動幫我們加上分號，這有時候可能會造成一些問題。","fields":{"slug":"/weird-JavaScript_27/"},"frontmatter":{"date":"2019-08-21","update":"0001-01-01","title":"Wierd JavaScript - 27：自動插入分號","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"再強調一次，什麼是語法解析器？","fields":{"slug":"/weird-JavaScript_26/"},"frontmatter":{"date":"2019-08-20","update":"0001-01-01","title":"Wierd JavaScript - 26：語法解析器","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"許多程式語言中都有重載函式的設定，但 JavaScript 卻沒有。為什麼？","fields":{"slug":"/weird-JavaScript_25/"},"frontmatter":{"date":"2019-08-20","update":"0001-01-01","title":"Wierd JavaScript - 25：重載函式","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"函式的參數（Parameter）和參數  有什麼關係？","fields":{"slug":"/weird-JavaScript_24/"},"frontmatter":{"date":"2019-08-17","update":"0001-01-01","title":"Wierd JavaScript - 24：參數（parameter v.s. arguments）","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"講了那麼多的物件和函式，現在終於輪到不可或缺的邊緣人－陣列。","fields":{"slug":"/weird-JavaScript_23/"},"frontmatter":{"date":"2019-08-17","update":"0001-01-01","title":"Wierd JavaScript - 23：陣列","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"你指的 this 到底是哪個 this ？","fields":{"slug":"/weird-JavaScript_22/"},"frontmatter":{"date":"2019-08-16","update":"0001-01-01","title":"Wierd JavaScript - 22：What's this ?","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"傳值 v.s. 傳參考， JavaScript 偷偷做但不告訴你的概念。","fields":{"slug":"/weird-JavaScript_21/"},"frontmatter":{"date":"2019-08-15","update":"0001-01-01","title":"Wierd JavaScript - 21：傳值 v.s. 傳參考","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"JavaScript 的兩種句型：陳述式和表達式。","fields":{"slug":"/weird-JavaScript_20/"},"frontmatter":{"date":"2019-08-15","update":"0001-01-01","title":"Wierd JavaScript - 20：函式陳述式與函式表達式","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"函式就是物件，物件就是函式，就是所謂一級函式。","fields":{"slug":"/weird-JavaScript_19/"},"frontmatter":{"date":"2019-08-14","update":"0001-01-01","title":"Wierd JavaScript - 19：一級函式","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"什麼？你說 JSON 就是物件？大錯特錯！","fields":{"slug":"/weird-JavaScript_18/"},"frontmatter":{"date":"2019-08-14","update":"0001-01-01","title":"Wierd JavaScript - 18：JSON v.s. 物件","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"當我們想要用相同的變數名稱來代指相似的資料，可以利用物件來建立偽裝的命名空間，避免資料被覆寫。","fields":{"slug":"/weird-JavaScript_17/"},"frontmatter":{"date":"2019-08-14","update":"0001-01-01","title":"Wierd JavaScript - 17：偽裝命名空間","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"學習取用物件的屬性和方法。","fields":{"slug":"/weird-JavaScript_16/"},"frontmatter":{"date":"2019-08-13","update":"0001-01-01","title":"Wierd JavaScript - 16：物件的屬性、方法以及取用","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"請用物件實字法創造物件。","fields":{"slug":"/weird-JavaScript_15/"},"frontmatter":{"date":"2019-08-12","update":"0001-01-01","title":"Wierd JavaScript - 15：創造物件、物件實字","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"小飛：「所以， JS 的動態型別與強制型轉到底有什麼用？」 有！這兩大特色幫助我們輕鬆判斷條件，設定預設值。","fields":{"slug":"/weird-JavaScript_14/"},"frontmatter":{"date":"2019-08-12","update":"0001-01-01","title":"Wierd JavaScript - 14：存在與布林、條件判斷與預設值","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"強制型轉（Coercion）， JavaScript 偷偷幫我們處理但不告訴我們的事情。","fields":{"slug":"/weird-JavaScript_13/"},"frontmatter":{"date":"2019-08-12","update":"0001-01-01","title":"Wierd JavaScript - 13：強制型轉","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"瞭解運算子的優先性與相依性，我們才知道許多種類的運算子擺在一起時，誰會先處理？從哪裡開始處理？","fields":{"slug":"/weird-JavaScript_12/"},"frontmatter":{"date":"2019-08-11","update":"0001-01-01","title":"Wierd JavaScript - 12：運算子的優先性與相依性","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"運算子就是用符號表示的函式。","fields":{"slug":"/weird-JavaScript_11/"},"frontmatter":{"date":"2019-08-11","update":"0001-01-01","title":"Wierd JavaScript - 11：運算子","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"JavaScript 將資料分為基本型別與物件型別兩類，那麼 JS 內建的資料型別到底有幾種呢？","fields":{"slug":"/weird-JavaScript_10/"},"frontmatter":{"date":"2019-08-10","update":"0001-01-01","title":"Wierd JavaScript - 10：基本型別（純值）與物件型別","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"資料是程式語言之本，來談談 JavaScript 怎麼處理資料的？","fields":{"slug":"/weird-JavaScript_09/"},"frontmatter":{"date":"2019-08-10","update":"0001-01-01","title":"Wierd JavaScript - 09：動態型別","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"小飛：「既然範圍鍊能讓函式向外部環境取用變數，那是不是把所有變數都存進全域就好了？」 恰恰相反！實務上，我們會避免污染全域，減少全域變數的產生。","fields":{"slug":"/weird-JavaScript_08/"},"frontmatter":{"date":"2019-08-09","update":"0001-01-01","title":"Wierd JavaScript - 08：作用域、let 與區塊作用域","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"判斷變數屬於全域變數（Global Variable）還是區域變數（Local Variable），我們就得看變數宣告所在的位置，也就是變數環境。","fields":{"slug":"/weird-JavaScript_07/"},"frontmatter":{"date":"2019-08-08","update":"0001-01-01","title":"Wierd JavaScript - 07：變數環境與範圍鍊","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"每當我們呼叫一個函式，JS 會立即建立屬於該函式的執行環境，然後堆起來（？）","fields":{"slug":"/weird-JavaScript_06/"},"frontmatter":{"date":"2019-08-07","update":"0001-01-01","title":"Wierd JavaScript - 06：呼叫函式、執行堆疊","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"JavaScript 本身是一門單執行緒且同步執行的高階程式語言。","fields":{"slug":"/weird-JavaScript_05/"},"frontmatter":{"date":"2019-08-06","update":"0001-01-01","title":"Wierd JavaScript - 05：單執行緒、同步執行、非同步回呼","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"我們之前提過： JavaScript 的執行環境不只包含你寫的 Code，因為它必須經過編譯器轉換。 所以，JavaScript 的執行脈絡到底包含哪些事情是我們不知道的？ 其中，最重要的就是 Creation 與 Hoisting 。","fields":{"slug":"/weird-JavaScript_04/"},"frontmatter":{"date":"2019-08-06","update":"0001-01-01","title":"Wierd JavaScript - 04：創造、提升與 undefined","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"還記得之前提到的執行脈絡／環境（Execution Context）嗎？","fields":{"slug":"/weird-JavaScript_03/"},"frontmatter":{"date":"2019-08-05","update":"0001-01-01","title":"Wierd JavaScript - 03：全域環境與全域物件","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"Name/Value Pair？ Key/Value Pair？沒差啦！反正就得成雙成對。","fields":{"slug":"/weird-JavaScript_02/"},"frontmatter":{"date":"2019-08-05","update":"0001-01-01","title":"Wierd JavaScript - 02：Name / Value Pair 與物件","tags":["Wierd JavaScript"]}}},{"node":{"excerpt":"相信你看完這篇就不會想學 JavaScript 了。","fields":{"slug":"/weird-JavaScript_01/"},"frontmatter":{"date":"2019-08-04","update":"0001-01-01","title":"Wierd JavaScript - 01：語法解析、詞彙環境、執行脈絡","tags":["Wierd JavaScript"]}}}]}]}},"pageContext":{}},"staticQueryHashes":["2027115977"]}
{"componentChunkName":"component---src-templates-post-tsx","path":"/weird-JavaScript_08/","result":{"data":{"markdownRemark":{"html":"<p>小飛：「既然範圍鍊能讓函式向外部環境取用變數，那是不是把所有變數都存進全域就好了？」</p>\n<p>恰恰相反！實務上，我們會<strong>避免污染全域</strong>，減少全域變數的產生。</p>\n<!-- more -->\n<h2 id=\"為什麼要避免污染全域\" style=\"position:relative;\"><a href=\"#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E9%81%BF%E5%85%8D%E6%B1%A1%E6%9F%93%E5%85%A8%E5%9F%9F\" aria-label=\"為什麼要避免污染全域 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>為什麼要避免污染全域？</h2>\n<hr>\n<p>因為實務上，一支 JavaScript 腳本，也就是 <code class=\"language-text\">.js</code> 檔案，往往會由多位工程師協作撰寫，除此之外，一支 <code class=\"language-text\">.html</code> 檔案也有可能會載入多支 JS 腳本，在這些多人開發的情況下，如果不同開發者不小心在全域環境中使用了相同的變數名稱，那麼後撰寫或後載入的變數，就會覆寫既有變數的值，導致衝突，不易於管理。</p>\n<p>所以，實務上我們會避免污染全域環境，減少全域變數的宣告。</p>\n<p>小飛：「意思是盡量要把變數宣告進函式裡，成為區域變數囉？」</p>\n<p>可以這麼說，我們利用作用域的特性，將變數存進函式區塊中，等到要用的時候再存取。<strong>閉包（Closure）</strong>的原理就是從這個概念出發的。我們之後會談到。</p>\n<h2 id=\"作用域scope\" style=\"position:relative;\"><a href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9Fscope\" aria-label=\"作用域scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>作用域（Scope）</h2>\n<hr>\n<blockquote>\n<p>Where a variable is <strong>available</strong> in your code.</p>\n</blockquote>\n<p>在 07 篇中我們就已經提過作用域：在函式內宣告的區域變數，只在該函式的執行環境內有效。</p>\n<p>換個方式說，詮釋作用域可以詮釋為：<strong>一個變數可以被取用的有效範圍</strong>。</p>\n<p>全域變數因為存在全域環境裡，所以能夠被任何函式取用，也就是範圍鍊的最外層。</p>\n<p>區域變數因為被宣告在某一函式裡，所以只能夠在<strong>該函式的執行環境內</strong>被取用，當然，也能被該函式內的其他函式取用。</p>\n<p>這裡要特別闡述「該函式的執行環境內」，指的是<strong>大括號 <code class=\"language-text\">{ ... }</code> 所框出的範圍</strong>。</p>\n<p>所以，我們可以說，<strong>函式是切分變數有效範圍（變數環境、作用域）的最小單位</strong>。</p>\n<p>在 <strong>ECMAScript 第六版（俗稱 ES6）</strong>發布以前，我們只能用 <code class=\"language-text\">var</code> 來宣告變數，於是會出現一些弔詭的現象，其中以下面這個範例最為經典：</p>\n<blockquote>\n<p>我希望在五秒內，每一秒就印出一個數字，分別是 0、1、2、3、4 。</p>\n</blockquote>\n<p>新手小飛可能會這樣寫：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>但是他會發現結果不如預期，這段程式碼執行的結果是：<strong>「1 秒後印出五個 5」</strong>。</p>\n<p><span style=\"font-size: 36px\">OMG !! WHY ??</font></p>\n<p>這是因為，當我們在 <code class=\"language-text\">for</code> 迴圈中使用 <code class=\"language-text\">var</code> 來宣告 <code class=\"language-text\">i</code> 時，此時的 <strong><code class=\"language-text\">i</code> 會被存進全域環境</strong>，成為全域變數。</p>\n<p>真的？請接續上面程式碼，執行 <code class=\"language-text\">console.log(window.i)</code> ， JS 會回你 <code class=\"language-text\">5</code>。</p>\n<p>這個例子還要結合<strong>非同步回呼</strong>的概念來解釋。還記得嗎？ JS 遇到需要時間處理的非同步事件（函式）時，他會先把它丟進事件佇列，等到執行堆疊為空後才處理。</p>\n<p><code class=\"language-text\">for</code> 跑第一次時， <code class=\"language-text\">var</code> 宣告 <code class=\"language-text\">i = 0</code> ，接著遇到 <code class=\"language-text\">setTimeout</code> ，JS 把 <code class=\"language-text\">setTimeout</code> 丟進事件佇列（因為等待 1 秒需要時間），接著迭代 <code class=\"language-text\">i++</code> 。然後，開始跑第二次 <code class=\"language-text\">for</code> ，由於經過 <code class=\"language-text\">var</code> 宣告的 <code class=\"language-text\">i</code> 是全域變數，此時 <code class=\"language-text\">i = 1</code> 會覆寫既有的 <code class=\"language-text\">0</code> ， 接著遇到 <code class=\"language-text\">setTimeout</code> ，JS 又會把 <code class=\"language-text\">setTimeout</code> 丟進事件佇列...</p>\n<p>所以，跑到最後一次，也就是第五次 <code class=\"language-text\">for</code> 結束時， <code class=\"language-text\">i = 5</code> ，全域執行環境也沒東西了，JS 就會回呼執行事件佇列裡面的五個 <code class=\"language-text\">setTimeout</code> ，而此時 <code class=\"language-text\">console.log(i)</code> 裡的 <code class=\"language-text\">i</code> 自然而然等於 <code class=\"language-text\">5</code>，執行的結果就會印出「五個 5」了。</p>\n<p>至於為什麼是「1 秒後」？而不是每 1 秒印出一個 5 ？那是因為 JS 執行很快，五個 <code class=\"language-text\">setTimeout</code> <strong>在我們看來</strong>幾乎同時執行。</p>\n<p>所以整體執行結果就會是「1 秒後印出五個 5」。</p>\n<p>對非同步回呼的概念應該比較熟悉了吧？</p>\n<p>回到本篇重點，在這個經典範例中，用 <code class=\"language-text\">var</code> 宣告變數的弔詭現象就是：當我們在 <code class=\"language-text\">for</code> 迴圈中使用 <code class=\"language-text\">var</code> 來宣告 <code class=\"language-text\">i</code> 時，此時的 <code class=\"language-text\">i</code> 會被存進全域環境，成為全域變數。</p>\n<p>仔細觀察會發現，<code class=\"language-text\">var i = 0</code> 並不在函式大括號 <code class=\"language-text\">{ ... }</code> 裡面，而是在 <code class=\"language-text\">for( ... )</code> 中，所以 <code class=\"language-text\">i</code> 自然會存進全域環境。</p>\n<p>2015 年 ES6 新增的 <code class=\"language-text\">let</code> 宣告，將變數綁定在 <code class=\"language-text\">{ ... }</code> 區塊，更清楚、有效切分作用域和變數環境。</p>\n<h2 id=\"let-與區塊作用域block-scope\" style=\"position:relative;\"><a href=\"#let-%E8%88%87%E5%8D%80%E5%A1%8A%E4%BD%9C%E7%94%A8%E5%9F%9Fblock-scope\" aria-label=\"let 與區塊作用域block scope permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>let 與區塊作用域（Block Scope）</h2>\n<hr>\n<p>簡單來說， <code class=\"language-text\">let</code> 宣告有下列幾個特點：</p>\n<ol>\n<li>\n<p>經過 <code class=\"language-text\">let</code> 宣告的變數，會將該變數環境綁定在其後的 <code class=\"language-text\">{ ... }</code> <strong>區塊作用域</strong>中，包括：</p>\n<ul>\n<li><code class=\"language-text\">function(){ ... }</code></li>\n<li><code class=\"language-text\">for(){ ... }</code></li>\n<li><code class=\"language-text\">if(){ ... }</code></li>\n</ul>\n</li>\n</ol>\n<p>既然如此，我們就可以利用 <code class=\"language-text\">let</code> 改寫上面那一段程式碼，在 <code class=\"language-text\">for</code> 中利用 <code class=\"language-text\">let</code> 宣告 <code class=\"language-text\">i</code> ，將其作用域綁定在後方 <code class=\"language-text\">{ ... }</code> 中，達到我們預期的目的：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>　<span class=\"token comment\">// 乘上 i 是為了延遲函式執行，得到「每 1 秒後」印出一個數字的效果。</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>經過 <code class=\"language-text\">let</code> 宣告的 <code class=\"language-text\">i</code> 作用域會被綁在 <code class=\"language-text\">{ ... }</code> 區塊中，當 JS 要把 <code class=\"language-text\">setTimeout</code> 丟進事件佇列時， <code class=\"language-text\">console.log(i)</code> 裡的 <code class=\"language-text\">i</code> 已經能夠取用區塊作用域裡的 <code class=\"language-text\">i</code> ，所以會連同 <code class=\"language-text\">i</code> 的值一起打包丟進事件佇列。等到 JS 最後執行時，就能夠印出  <strong>「0、1、2、3、4」</strong>。</p>\n<p>必須特別強調的是，在 <code class=\"language-text\">for</code> 迴圈中，每次跑的區塊都是<strong>獨立的</strong>，也就是說，<code class=\"language-text\">for</code> 第一次跑的 <code class=\"language-text\">{ ... }</code> 和第二次跑的 <code class=\"language-text\">{ ... }</code> 並不一樣，每次經過 <code class=\"language-text\">let</code> 宣告的 <code class=\"language-text\">i</code> ，在電腦的記憶體位置也不一樣，所以才能被 <code class=\"language-text\">setTimeout</code> 取用並打包丟進事件佇列。</p>\n<p>其實上面這段範例可以利用<strong>立即執行函式運算式（IIFE）</strong>解構成下面這段程式碼：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// for 跑第一次所建立的 block （執行環境）</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>　\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// for 跑第二次所建立的 block （執行環境）</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">;</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>　\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//...</span>\n<span class=\"token comment\">// for 跑第五次所建立的 block （執行環境）</span>\n<span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">4</span> <span class=\"token punctuation\">;</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span> <span class=\"token operator\">*</span> i<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>　\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span></code></pre></div>\n<ol start=\"2\">\n<li>經過 <code class=\"language-text\">let</code> 宣告的變數，無論在哪宣告，都不會被存進全域環境，即便宣告在全域中。 </li>\n</ol>\n<p>直接用程式碼印證：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> animal <span class=\"token operator\">=</span> <span class=\"token string\">'giraffe'</span> <span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>animal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// giraffe</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>animal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined（window.animal 找不到任何值）</span></code></pre></div>\n<p><strong>雖然不會被存進全域，但可以被參考取用：</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> animal <span class=\"token operator\">=</span> <span class=\"token string\">'giraffe'</span> <span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">outer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> perosn <span class=\"token operator\">=</span> <span class=\"token string\">'Fei'</span> <span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>animal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// giraffe</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">inner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>animal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// giraffe</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>perosn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// Fei</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">inner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">outer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span></code></pre></div>\n<ol start=\"3\">\n<li>在同個區塊作用域中，只能用 <code class=\"language-text\">let</code> 宣告一次，且宣告後在區塊中可以被覆寫。</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> animal <span class=\"token operator\">=</span> <span class=\"token string\">'griaffe'</span> <span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> animal <span class=\"token operator\">=</span> <span class=\"token string\">'tiger'</span> <span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>animal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// tiger </span>\n  animal <span class=\"token operator\">=</span> <span class=\"token string\">'lion'</span> <span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>animal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// lion </span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>animal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// giraffe  </span>\n<span class=\"token keyword\">let</span> animal <span class=\"token operator\">=</span> <span class=\"token string\">'panda'</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught SyntaxError: Identifier 'animal' has already been declared</span>\nanimal <span class=\"token operator\">=</span> <span class=\"token string\">'panda'</span> <span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>animal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// panda</span></code></pre></div>\n<p>不同區塊作用域中，當然可以用相同名稱 <code class=\"language-text\">let</code> 宣告變數，因為<strong>區塊不同， <code class=\"language-text\">let</code> 宣告的變數所佔據的記憶體位置就不同</strong>。</p>\n<ol start=\"4\">\n<li>經過 <code class=\"language-text\">let</code> 宣告的變數沒有 Hoisting 的特性。</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>animal<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// Uncaught ReferenceError: Cannot access 'animal' before initialization</span>\n<span class=\"token keyword\">let</span> animal <span class=\"token operator\">=</span> <span class=\"token string\">'griaffe'</span> <span class=\"token punctuation\">;</span> </code></pre></div>\n<p>實務上，現在我們多以 <code class=\"language-text\">let</code> 宣告來取代 <code class=\"language-text\">var</code> ，避免對全域環境的污染。</p>\n<p>此外， ES6 還有新增另一種語法 <strong><code class=\"language-text\">const</code> 常數宣告</strong>，它的特點幾乎與 <code class=\"language-text\">let</code> 相同，唯一不同的是，<strong>經過 <code class=\"language-text\">const</code> 宣告的變數無法被覆寫（具有唯讀性）</strong>，最常被用在賦值 DOM 元素。</p>\n<h2 id=\"結論\" style=\"position:relative;\"><a href=\"#%E7%B5%90%E8%AB%96\" aria-label=\"結論 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>結論</h2>\n<hr>\n<ul>\n<li>實務上，我們會避免污染全域，減少全域變數的衝突發生。</li>\n<li>\n<p>當今我們多用 <code class=\"language-text\">let</code> 宣告取代 <code class=\"language-text\">var</code> 來避免污染全域。</p>\n<ul>\n<li>經過 <code class=\"language-text\">let</code> 宣告的變數，會將該變數環境綁定在 <code class=\"language-text\">{ ... }</code> 區塊作用域中。</li>\n<li>經過 <code class=\"language-text\">let</code> 宣告的變數，無論你在哪裡宣告，都不會被存進全域環境。</li>\n<li>經過 <code class=\"language-text\">let</code> 宣告的變數沒有 Hoisting 的特性。</li>\n<li>在同個區塊作用域中，只能用 <code class=\"language-text\">let</code> 宣告一次，且宣告後在區塊中可以被覆寫。</li>\n</ul>\n</li>\n<li>總而言之，函式區塊是切分變數環境（也就是變數作用域）的最小單位。</li>\n</ul>\n<h2 id=\"參考資料\" style=\"position:relative;\"><a href=\"#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\" aria-label=\"參考資料 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>參考資料</h2>\n<hr>\n<ol>\n<li>JavaScript 全攻略：克服 JS 奇怪的部分 2-17、2-18</li>\n<li><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/let\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN：let</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/const\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN：const</a></li>\n<li><a href=\"https://kuro.tw/posts/2019/02/23/%E8%AB%87%E8%AB%87-JavaScript-%E7%9A%84-setTimeout-%E8%88%87-setInterval/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">談談 JavaScript 的 setTimeout 與 setInterval</a></li>\n<li><a href=\"https://cythilya.github.io/2018/10/19/function-vs-block-scope/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">你懂 JavaScript 嗎？#12 函式範疇與區塊範疇（Function vs Block Scope）</a></li>\n</ol>","excerpt":"小飛：「既然範圍鍊能讓函式向外部環境取用變數，那是不是把所有變數都存進全域就好了？」 恰恰相反！實務上，我們會避免污染全域，減少全域變數的產生。","tableOfContents":"<ul>\n<li><a href=\"/weird-JavaScript_08/#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E9%81%BF%E5%85%8D%E6%B1%A1%E6%9F%93%E5%85%A8%E5%9F%9F\">為什麼要避免污染全域？</a></li>\n<li><a href=\"/weird-JavaScript_08/#%E4%BD%9C%E7%94%A8%E5%9F%9Fscope\">作用域（Scope）</a></li>\n<li><a href=\"/weird-JavaScript_08/#let-%E8%88%87%E5%8D%80%E5%A1%8A%E4%BD%9C%E7%94%A8%E5%9F%9Fblock-scope\">let 與區塊作用域（Block Scope）</a></li>\n<li><a href=\"/weird-JavaScript_08/#%E7%B5%90%E8%AB%96\">結論</a></li>\n<li><a href=\"/weird-JavaScript_08/#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\">參考資料</a></li>\n</ul>","fields":{"slug":"/weird-JavaScript_08/"},"frontmatter":{"title":"Wierd JavaScript - 08：作用域、let 與區塊作用域","date":"2019-08-09","update":"0001-01-01","tags":["Wierd JavaScript"],"keywords":["Luffy on the Way","Luffy Chen"],"featuredImage":null}}},"pageContext":{"slug":"/weird-JavaScript_08/","series":[{"slug":"/weird-JavaScript_01/","title":"Wierd JavaScript - 01：語法解析、詞彙環境、執行脈絡","num":1},{"slug":"/weird-JavaScript_02/","title":"Wierd JavaScript - 02：Name / Value Pair 與物件","num":2},{"slug":"/weird-JavaScript_03/","title":"Wierd JavaScript - 03：全域環境與全域物件","num":3},{"slug":"/weird-JavaScript_04/","title":"Wierd JavaScript - 04：創造、提升與 undefined","num":4},{"slug":"/weird-JavaScript_05/","title":"Wierd JavaScript - 05：單執行緒、同步執行、非同步回呼","num":5},{"slug":"/weird-JavaScript_06/","title":"Wierd JavaScript - 06：呼叫函式、執行堆疊","num":6},{"slug":"/weird-JavaScript_07/","title":"Wierd JavaScript - 07：變數環境與範圍鍊","num":7},{"slug":"/weird-JavaScript_08/","title":"Wierd JavaScript - 08：作用域、let 與區塊作用域","num":8},{"slug":"/weird-JavaScript_09/","title":"Wierd JavaScript - 09：動態型別","num":9},{"slug":"/weird-JavaScript_10/","title":"Wierd JavaScript - 10：基本型別（純值）與物件型別","num":10},{"slug":"/weird-JavaScript_11/","title":"Wierd JavaScript - 11：運算子","num":11},{"slug":"/weird-JavaScript_12/","title":"Wierd JavaScript - 12：運算子的優先性與相依性","num":12},{"slug":"/weird-JavaScript_13/","title":"Wierd JavaScript - 13：強制型轉","num":13},{"slug":"/weird-JavaScript_14/","title":"Wierd JavaScript - 14：存在與布林、條件判斷與預設值","num":14},{"slug":"/weird-JavaScript_15/","title":"Wierd JavaScript - 15：創造物件、物件實字","num":15},{"slug":"/weird-JavaScript_16/","title":"Wierd JavaScript - 16：物件的屬性、方法以及取用","num":16},{"slug":"/weird-JavaScript_17/","title":"Wierd JavaScript - 17：偽裝命名空間","num":17},{"slug":"/weird-JavaScript_18/","title":"Wierd JavaScript - 18：JSON v.s. 物件","num":18},{"slug":"/weird-JavaScript_19/","title":"Wierd JavaScript - 19：一級函式","num":19},{"slug":"/weird-JavaScript_20/","title":"Wierd JavaScript - 20：函式陳述式與函式表達式","num":20},{"slug":"/weird-JavaScript_21/","title":"Wierd JavaScript - 21：傳值 v.s. 傳參考","num":21},{"slug":"/weird-JavaScript_22/","title":"Wierd JavaScript - 22：What's this ?","num":22},{"slug":"/weird-JavaScript_23/","title":"Wierd JavaScript - 23：陣列","num":23},{"slug":"/weird-JavaScript_24/","title":"Wierd JavaScript - 24：參數（parameter v.s. arguments）","num":24},{"slug":"/weird-JavaScript_25/","title":"Wierd JavaScript - 25：重載函式","num":25},{"slug":"/weird-JavaScript_26/","title":"Wierd JavaScript - 26：語法解析器","num":26},{"slug":"/weird-JavaScript_27/","title":"Wierd JavaScript - 27：自動插入分號","num":27},{"slug":"/weird-JavaScript_28/","title":"Wierd JavaScript - 28：空格","num":28},{"slug":"/weird-JavaScript_29/","title":"Wierd JavaScript - 29：立即呼叫函式表達式（IIFEs）","num":29},{"slug":"/weird-JavaScript_30/","title":"Wierd JavaScript - 30：IIFEs 與安全程式碼","num":30},{"slug":"/weird-JavaScript_31/","title":"Wierd JavaScript - 31：閉包（1）","num":31},{"slug":"/weird-JavaScript_32/","title":"Wierd JavaScript - 32：閉包（2）","num":32},{"slug":"/weird-JavaScript_33/","title":"Wierd JavaScript - 33：函式工廠","num":33},{"slug":"/weird-JavaScript_34/","title":"Wierd JavaScript - 34：閉包與回呼","num":34},{"slug":"/weird-JavaScript_35/","title":"Wierd JavaScript - 35：call()、apply()、bind()","num":35},{"slug":"/weird-JavaScript_36/","title":"Wierd JavaScript - 36：函式程式設計（一）","num":36},{"slug":"/weird-JavaScript_37/","title":"Wierd JavaScript - 37：函式程式設計（二）","num":37},{"slug":"/weird-JavaScript_38/","title":"Wierd JavaScript - 38：古典繼承 v.s. 原型繼承","num":38},{"slug":"/weird-JavaScript_39/","title":"Wierd JavaScript - 39：原型與原型鍊","num":39},{"slug":"/weird-JavaScript_40/","title":"Wierd JavaScript - 40：所有東西都是物件（或純值）","num":40}],"lastmod":"2019-08-09"}},"staticQueryHashes":["2027115977"]}
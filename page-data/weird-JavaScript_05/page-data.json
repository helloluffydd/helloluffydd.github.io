{"componentChunkName":"component---src-templates-post-tsx","path":"/weird-JavaScript_05/","result":{"data":{"markdownRemark":{"html":"<p>JavaScript <strong>本身</strong>是一門<strong>單執行緒</strong>且<strong>同步執行</strong>的高階程式語言。</p>\n<!-- more -->\n<h2 id=\"單執行緒single-threaded\" style=\"position:relative;\"><a href=\"#%E5%96%AE%E5%9F%B7%E8%A1%8C%E7%B7%92single-threaded\" aria-label=\"單執行緒single threaded permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>單執行緒（Single Threaded）</h2>\n<hr>\n<blockquote>\n<p><strong>One command at a time.</strong></p>\n</blockquote>\n<p>單執行緒的意思是， JavaScript 一次<strong>只能做一件事情</strong>（一行指令）。</p>\n<h2 id=\"同步執行synchronous-execution\" style=\"position:relative;\"><a href=\"#%E5%90%8C%E6%AD%A5%E5%9F%B7%E8%A1%8Csynchronous-execution\" aria-label=\"同步執行synchronous execution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>同步執行（Synchronous Execution）</h2>\n<hr>\n<blockquote>\n<p><strong>One at a time and in order.</strong></p>\n</blockquote>\n<p>同步執行的意思是， JavaScript 一次只能做一件事情，這件做完，才能做下一件，<strong>按照順序一件接著一件</strong>（逐行執行命令）。</p>\n<p>小飛：「可是我聽過 JavaScript 有一個特色叫做 <strong>非同步（Asynchronous）</strong>耶？」</p>\n<p>好，既然你誠心誠意發問了，我就...</p>\n<h2 id=\"非同步asynchronous\" style=\"position:relative;\"><a href=\"#%E9%9D%9E%E5%90%8C%E6%AD%A5asynchronous\" aria-label=\"非同步asynchronous permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>非同步（Asynchronous）</h2>\n<hr>\n<p><strong>More than one at a time.</strong></p>\n<p>非同步的意思是，「同時間可以做不只一件事」。</p>\n<p>注意！我說的<strong>不是</strong> JavaScript。再次強調，<strong>JS 引擎是同步執行的</strong>，一次只能做一件事且按照指令順序。</p>\n<p>那為什麼非同步會是 JavaScript 的特色呢？那是因為<strong>JavaScript 引擎可以和瀏覽器內其他引擎溝通，互相合作</strong>。</p>\n<p>事實上，瀏覽器裡不只包含 JS 引擎，也包含負責畫面呈現的<strong>渲染引擎（Rendering Engine）</strong>、獲取伺服器資料的 <strong>請求方法（HTTP Request Methods）</strong> 等等。</p>\n<p>而 JavaScript 引擎內有個東西叫作<strong>事件佇列（Event Queue）</strong>，<strong>JS 會把需要和其他引擎合作的事件，暫時放在事件佇列裡等待處理</strong>。</p>\n<p>這裡可以用兩個例子來說明。</p>\n<h3 id=\"例1-js-與-rendering-engine-合作的非同步事件\" style=\"position:relative;\"><a href=\"#%E4%BE%8B1-js-%E8%88%87-rendering-engine-%E5%90%88%E4%BD%9C%E7%9A%84%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BA%8B%E4%BB%B6\" aria-label=\"例1 js 與 rendering engine 合作的非同步事件 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例1. JS 與 Rendering Engine 合作的非同步事件</h3>\n<p>當我們在 JavaScript 中監聽一則 <code class=\"language-text\">click</code> 事件，因為它需要使用者點擊滑鼠來觸發事件，所以 JS 會把這個事件暫時放進事件佇列中，<strong>等到 JS 逐行跑完（全域執行環境的）指令，也就是執行堆疊（Execution Stack）為空以後</strong>，再來執行這則 <code class=\"language-text\">click</code> 事件（事件觸發後由 Rendering Engine 渲染畫面）。譬如下面這段程式碼：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// 全域執行開始</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'start execution (time countdown starts)'</span><span class=\"token punctuation\">)</span> \n<span class=\"token keyword\">function</span> <span class=\"token function\">waitFiveSeconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> endTime <span class=\"token operator\">=</span> <span class=\"token number\">5000</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> endTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>　<span class=\"token comment\">// 5 秒內不會做任何事，此時點擊網頁，click 事件不會立刻被執行，而是被放進事件佇列等待。</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'finished function (5 seconds passed)'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>　\n  <span class=\"token comment\">// 函式 waitFiveSeconds 結束（結束 waitFiveSeconds 執行堆疊）</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">clickHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>　<span class=\"token comment\">// 宣告　click 事件（函式）</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click event !'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\ndocument<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span>clickHandler<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 註冊 click 事件</span>\n\n<span class=\"token function\">waitFiveSeconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span> <span class=\"token comment\">// 執行函式 waitFiveSeconds （建立 waitFiveSeconds 執行堆疊）</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'finished execution'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>　\n<span class=\"token comment\">// 全域執行結束，開始執行事件佇列的事件（執行 clickHandler -> 印出 'click event !' -> 結束 clickHandler）。</span>\n<span class=\"token comment\">// 持續檢查事件佇列，若有新的事件觸發（被丟進佇列），便立即執行。</span></code></pre></div>\n<p>執行結果如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"plain\"><pre class=\"language-plain\"><code class=\"language-plain\">start execution (time countdown starts)\nfinished function (5 seconds passed)\nfinished execution\nclick event !　// 你點擊網頁（觸發 click）多少次，這裡就會有多少個 click event !</code></pre></div>\n<h3 id=\"例2-js-與-http-request-合作的非同步事件\" style=\"position:relative;\"><a href=\"#%E4%BE%8B2-js-%E8%88%87-http-request-%E5%90%88%E4%BD%9C%E7%9A%84%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BA%8B%E4%BB%B6\" aria-label=\"例2 js 與 http request 合作的非同步事件 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>例2. JS 與 HTTP Request 合作的非同步事件</h3>\n<p>當我們在 JavaScript 中利用 HTTP Request 向伺服器發出一則資料請求，由於等待回覆（Response）必然耗時，所以 JS 會把這個請求（Request）暫時放進事件佇列中<strong>等待回覆</strong>（請求已經發出，並由 HTTP Request Methods 執行），<strong>等到 JS 逐行跑完（全域執行環境的）指令，也就是執行堆疊（Execution Stack）為空以後</strong>，再來處理伺服器 Response 的資料。</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/70f8ef5c435ae92657e0d67711647a9f/d924d/eventQueue.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.19444444444445%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFAv/EABUBAQEAAAAAAAAAAAAAAAAAAAME/9oADAMBAAIQAxAAAAHVJFkaaBMGm//EABsQAAEEAwAAAAAAAAAAAAAAAAABAgQSAxEy/9oACAEBAAEFAtEbgqIy2BIrT//EABYRAAMAAAAAAAAAAAAAAAAAAAMQMv/aAAgBAwEBPwEkr//EABYRAAMAAAAAAAAAAAAAAAAAAAIQMf/aAAgBAgEBPwEKv//EAB0QAAICAQUAAAAAAAAAAAAAAAABAjEQESEyQZH/2gAIAQEABj8CqQ7vvFslHV7s5T9P/8QAGRABAAMBAQAAAAAAAAAAAAAAAQARITEQ/9oACAEBAAE/ITEcZD0BuCdB2Ub7T//aAAwDAQACAAMAAAAQB8//xAAVEQEBAAAAAAAAAAAAAAAAAAAQMf/aAAgBAwEBPxCx/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxAP/8QAHxABAAICAAcAAAAAAAAAAAAAAQARITEQYYGhscHw/9oACAEBAAE/EC97fiEpZTm0cA0HchzwLQGtPSXWSrfhP//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"JS 會優先處理腳本中的執行堆疊，最後才執行事件佇列。（圖片源自參考資料 1.）\"\n        title=\"JS 會優先處理腳本中的執行堆疊，最後才執行事件佇列。（圖片源自參考資料 1.）\"\n        src=\"/static/70f8ef5c435ae92657e0d67711647a9f/80e3c/eventQueue.jpg\"\n        srcset=\"/static/70f8ef5c435ae92657e0d67711647a9f/80e3c/eventQueue.jpg 720w,\n/static/70f8ef5c435ae92657e0d67711647a9f/fbd2c/eventQueue.jpg 1180w,\n/static/70f8ef5c435ae92657e0d67711647a9f/d924d/eventQueue.jpg 1238w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>JS 會優先處理腳本中的執行堆疊，最後才執行事件佇列。（圖片源自參考資料 1.）</p></figcaption>\n  </figure></p>\n<p>我們可以把事件佇列想像成 JS 引擎的對外窗口，每當 JS 遇到需要和其他引擎合作的事件，會將這些事件依序放進事件佇列，先專心跑完全域執行環境的程式碼後，再回頭逐一執行事件佇列裡的任務。</p>\n<p>你也可以把事件佇列想像成一個大函式，把需要<strong>非同步執行</strong>的事件都先放進去，爾後再拿出來執行。這樣的方式，就是所謂的<strong>非同步回呼（Asynchronous Callback）</strong>。而那些<strong>JS 需要和其他引擎合作的事件（函式）</strong>，或說，這些<strong>被 JS 放進事件佇列裡的事件（函式）</strong>，正是一種<strong>回呼函式（Callback Function）</strong>。</p>\n<p>用生活化的方式解釋回呼，大概就像這個情境：白白（JS）一次只能做一件事，他現在正在和客戶A講電話，突然客戶B來電，白白就寫了張MEMO（事件佇列）：「客戶A談完要打給客戶B」。下一秒客戶C又來電，於是白白又寫下：「B客戶談完後要打給C」。<del>然後就得加班了？</del></p>\n<p>關於回呼的概念我們之後有機會再細談，回到事件佇列上。</p>\n<p>當事件佇列裡排定的事件都處理完後，JS 也不會閒著，它會<strong>持續檢查（Continuous Check）</strong>事件佇列有沒有新的事件進來，如果有的話，就會立即處理，如 ※例1. 的程式碼。</p>\n<p>發現了嗎？ JavaScript 這樣的執行流程，依然是<strong>同步</strong>的：一次只做一件事，這個做完再做下一個，按順序執行。</p>\n<p>總而言之，JavaScript 本身雖然是<strong>同步</strong>的，但因為它能夠利用事件佇列與瀏覽器中的其他引擎互相溝通、分工合作，達到<strong>非同步</strong>的效果，非同步也就成為了 JS 的特色。</p>\n<p>最後，需要特別注意的是，<strong>JS 非同步的部分，發生在 JS 引擎之外</strong>，也就是其他協作引擎所執行的。</p>\n<h2 id=\"結論\" style=\"position:relative;\"><a href=\"#%E7%B5%90%E8%AB%96\" aria-label=\"結論 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>結論</h2>\n<hr>\n<ul>\n<li>JavaScript 本身是一門單執行緒且同步執行的高階程式語言，意思是，它一次只能做一件事情，而且必須按順序執行，執行完一件才能繼續做下一件。</li>\n<li>JavaScript 能夠利用事件佇列與瀏覽器中的其他引擎互相溝通、分工合作，利用同步達到非同步的效果，使得非同步成為 JS 的特色。</li>\n</ul>\n<h2 id=\"參考資料\" style=\"position:relative;\"><a href=\"#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\" aria-label=\"參考資料 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>參考資料</h2>\n<hr>\n<ol>\n<li>JavaScript 全攻略：克服 JS 奇怪的部分 2-13、2-18</li>\n<li><a href=\"https://ithelp.ithome.com.tw/articles/10191427\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">先來看看瀏覽器內核長怎樣吧！</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Callback_function\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">MDN：Callback function</a></li>\n</ol>","excerpt":"JavaScript 本身是一門單執行緒且同步執行的高階程式語言。","tableOfContents":"<ul>\n<li><a href=\"/weird-JavaScript_05/#%E5%96%AE%E5%9F%B7%E8%A1%8C%E7%B7%92single-threaded\">單執行緒（Single Threaded）</a></li>\n<li><a href=\"/weird-JavaScript_05/#%E5%90%8C%E6%AD%A5%E5%9F%B7%E8%A1%8Csynchronous-execution\">同步執行（Synchronous Execution）</a></li>\n<li>\n<p><a href=\"/weird-JavaScript_05/#%E9%9D%9E%E5%90%8C%E6%AD%A5asynchronous\">非同步（Asynchronous）</a></p>\n<ul>\n<li><a href=\"/weird-JavaScript_05/#%E4%BE%8B1-js-%E8%88%87-rendering-engine-%E5%90%88%E4%BD%9C%E7%9A%84%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BA%8B%E4%BB%B6\">例1. JS 與 Rendering Engine 合作的非同步事件</a></li>\n<li><a href=\"/weird-JavaScript_05/#%E4%BE%8B2-js-%E8%88%87-http-request-%E5%90%88%E4%BD%9C%E7%9A%84%E9%9D%9E%E5%90%8C%E6%AD%A5%E4%BA%8B%E4%BB%B6\">例2. JS 與 HTTP Request 合作的非同步事件</a></li>\n</ul>\n</li>\n<li><a href=\"/weird-JavaScript_05/#%E7%B5%90%E8%AB%96\">結論</a></li>\n<li><a href=\"/weird-JavaScript_05/#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\">參考資料</a></li>\n</ul>","fields":{"slug":"/weird-JavaScript_05/"},"frontmatter":{"title":"Wierd JavaScript - 05：單執行緒、同步執行、非同步回呼","date":"2019-08-06","update":"0001-01-01","tags":["Wierd JavaScript"],"keywords":["Luffy on the Way","Luffy Chen"],"featuredImage":{"publicURL":"/static/70f8ef5c435ae92657e0d67711647a9f/eventQueue.JPG"}}}},"pageContext":{"slug":"/weird-JavaScript_05/","series":[{"slug":"/weird-JavaScript_01/","title":"Wierd JavaScript - 01：語法解析、詞彙環境、執行脈絡","num":1},{"slug":"/weird-JavaScript_02/","title":"Wierd JavaScript - 02：Name / Value Pair 與物件","num":2},{"slug":"/weird-JavaScript_03/","title":"Wierd JavaScript - 03：全域環境與全域物件","num":3},{"slug":"/weird-JavaScript_04/","title":"Wierd JavaScript - 04：創造、提升與 undefined","num":4},{"slug":"/weird-JavaScript_05/","title":"Wierd JavaScript - 05：單執行緒、同步執行、非同步回呼","num":5},{"slug":"/weird-JavaScript_06/","title":"Wierd JavaScript - 06：呼叫函式、執行堆疊","num":6},{"slug":"/weird-JavaScript_07/","title":"Wierd JavaScript - 07：變數環境與範圍鍊","num":7},{"slug":"/weird-JavaScript_08/","title":"Wierd JavaScript - 08：作用域、let 與區塊作用域","num":8},{"slug":"/weird-JavaScript_09/","title":"Wierd JavaScript - 09：動態型別","num":9},{"slug":"/weird-JavaScript_10/","title":"Wierd JavaScript - 10：基本型別（純值）與物件型別","num":10},{"slug":"/weird-JavaScript_11/","title":"Wierd JavaScript - 11：運算子","num":11},{"slug":"/weird-JavaScript_12/","title":"Wierd JavaScript - 12：運算子的優先性與相依性","num":12},{"slug":"/weird-JavaScript_13/","title":"Wierd JavaScript - 13：強制型轉","num":13},{"slug":"/weird-JavaScript_14/","title":"Wierd JavaScript - 14：存在與布林、條件判斷與預設值","num":14},{"slug":"/weird-JavaScript_15/","title":"Wierd JavaScript - 15：創造物件、物件實字","num":15},{"slug":"/weird-JavaScript_16/","title":"Wierd JavaScript - 16：物件的屬性、方法以及取用","num":16},{"slug":"/weird-JavaScript_17/","title":"Wierd JavaScript - 17：偽裝命名空間","num":17},{"slug":"/weird-JavaScript_18/","title":"Wierd JavaScript - 18：JSON v.s. 物件","num":18},{"slug":"/weird-JavaScript_19/","title":"Wierd JavaScript - 19：一級函式","num":19},{"slug":"/weird-JavaScript_20/","title":"Wierd JavaScript - 20：函式陳述式與函式表達式","num":20},{"slug":"/weird-JavaScript_21/","title":"Wierd JavaScript - 21：傳值 v.s. 傳參考","num":21},{"slug":"/weird-JavaScript_22/","title":"Wierd JavaScript - 22：What's this ?","num":22},{"slug":"/weird-JavaScript_23/","title":"Wierd JavaScript - 23：陣列","num":23},{"slug":"/weird-JavaScript_24/","title":"Wierd JavaScript - 24：參數（parameter v.s. arguments）","num":24},{"slug":"/weird-JavaScript_25/","title":"Wierd JavaScript - 25：重載函式","num":25},{"slug":"/weird-JavaScript_26/","title":"Wierd JavaScript - 26：語法解析器","num":26},{"slug":"/weird-JavaScript_27/","title":"Wierd JavaScript - 27：自動插入分號","num":27},{"slug":"/weird-JavaScript_28/","title":"Wierd JavaScript - 28：空格","num":28},{"slug":"/weird-JavaScript_29/","title":"Wierd JavaScript - 29：立即呼叫函式表達式（IIFEs）","num":29},{"slug":"/weird-JavaScript_30/","title":"Wierd JavaScript - 30：IIFEs 與安全程式碼","num":30},{"slug":"/weird-JavaScript_31/","title":"Wierd JavaScript - 31：閉包（1）","num":31},{"slug":"/weird-JavaScript_32/","title":"Wierd JavaScript - 32：閉包（2）","num":32},{"slug":"/weird-JavaScript_33/","title":"Wierd JavaScript - 33：函式工廠","num":33},{"slug":"/weird-JavaScript_34/","title":"Wierd JavaScript - 34：閉包與回呼","num":34},{"slug":"/weird-JavaScript_35/","title":"Wierd JavaScript - 35：call()、apply()、bind()","num":35},{"slug":"/weird-JavaScript_36/","title":"Wierd JavaScript - 36：函式程式設計（一）","num":36},{"slug":"/weird-JavaScript_37/","title":"Wierd JavaScript - 37：函式程式設計（二）","num":37},{"slug":"/weird-JavaScript_38/","title":"Wierd JavaScript - 38：古典繼承 v.s. 原型繼承","num":38},{"slug":"/weird-JavaScript_39/","title":"Wierd JavaScript - 39：原型與原型鍊","num":39},{"slug":"/weird-JavaScript_40/","title":"Wierd JavaScript - 40：所有東西都是物件（或純值）","num":40}],"lastmod":"2019-08-06"}},"staticQueryHashes":["2027115977"]}
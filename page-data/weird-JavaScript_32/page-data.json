{"componentChunkName":"component---src-templates-post-tsx","path":"/weird-JavaScript_32/","result":{"data":{"markdownRemark":{"html":"<p>這題沒答對，你敢說你懂閉包？</p>\n<!-- more -->\n<h2 id=\"閉包概念的程式碼範例\" style=\"position:relative;\"><a href=\"#%E9%96%89%E5%8C%85%E6%A6%82%E5%BF%B5%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%AF%84%E4%BE%8B\" aria-label=\"閉包概念的程式碼範例 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>閉包概念的程式碼範例</h2>\n<hr>\n<p>請看下面這段程式碼，想一想這段程式碼在做什麼？</p>\n<p>你認為 <code class=\"language-text\">fs[0]()</code> 、 <code class=\"language-text\">fs[1]()</code> 、 <code class=\"language-text\">fs[2]()</code> 執行後，分別會印出什麼數字？</p>\n<p>請將答案紀錄在一張白紙上，再複製貼上這段程式碼至瀏覽器中，檢驗是否正確。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">buildFunctions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">buildFunctions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> arr <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nfs<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\nfs<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\nfs<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span></code></pre></div>\n<p>檢驗後答案如你所預期的一樣嗎？如果你答對的話，恭喜你（應該）已經掌握閉包的概念了！</p>\n<p>解釋這個例子的原理之前，有必要畫個防雷分隔線：</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>.</p>\n<p>沒錯，在這個例子中， <code class=\"language-text\">fs[0]()</code> 、 <code class=\"language-text\">fs[1]()</code> 、 <code class=\"language-text\">fs[2]()</code> 執行後，印出的結果都是 <code class=\"language-text\">3</code> 。</p>\n<p>許多人預期 <code class=\"language-text\">fs[0]()</code> 、 <code class=\"language-text\">fs[1]()</code> 、 <code class=\"language-text\">fs[2]()</code> 會分別印出 <code class=\"language-text\">0</code> 、 <code class=\"language-text\">1</code> 、 <code class=\"language-text\">2</code> ，怎麼會是 <code class=\"language-text\">3</code> ？這數字哪來的？</p>\n<p>簡單來說，這是因為：當你在<strong>執行</strong> <code class=\"language-text\">fs[0]()</code> 這三個函式的時候，它們所參考的外部（詞彙）環境 <code class=\"language-text\">buildFunctions()</code> 所儲存的區域變數 <code class=\"language-text\">i</code> ，已經是 <code class=\"language-text\">3</code> ，和你<strong>創造</strong> <code class=\"language-text\">fs[0]()</code> 這三個函式的時候的 <code class=\"language-text\">i</code> 是不一樣的。 </p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d52e9cc51cb11f47cda12d576da1613c/4b190/black.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 97.50000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQBAv/EABYBAQEBAAAAAAAAAAAAAAAAAAIAAf/aAAwDAQACEAMQAAABqUcB0sI96bk4r//EAB0QAAIBBAMAAAAAAAAAAAAAAAECAwAEEBIRISL/2gAIAQEAAQUCuF2jt/J7pUOkcTKx5oYdiD//xAAWEQADAAAAAAAAAAAAAAAAAAARICH/2gAIAQMBAT8BgT//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AR//xAAbEAACAwADAAAAAAAAAAAAAAAAAQIRIRIgUf/aAAgBAQAGPwKPljjFYaccLb6//8QAGxABAAIDAQEAAAAAAAAAAAAAAQARITFBUWH/2gAIAQEAAT8hQ6vQOxlaLNXMtQfkAkId5mq8KAgThJpGAK8n/9oADAMBAAIAAwAAABDMCEL/xAAXEQADAQAAAAAAAAAAAAAAAAABESAx/9oACAEDAQE/EGwHY//EABcRAAMBAAAAAAAAAAAAAAAAAAEQETH/2gAIAQIBAT8QhoiGL//EAB0QAQACAgMBAQAAAAAAAAAAAAEAESFBMVFhgbH/2gAIAQEAAT8QwnMurji/sAWCmhDf5MA9BVkHAtJfVXkhCmzdHsvtKtzgmBBZlNuPWf/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"黑人問號\"\n        title=\"黑人問號\"\n        src=\"/static/d52e9cc51cb11f47cda12d576da1613c/80e3c/black.jpg\"\n        srcset=\"/static/d52e9cc51cb11f47cda12d576da1613c/80e3c/black.jpg 720w,\n/static/d52e9cc51cb11f47cda12d576da1613c/4b190/black.jpg 800w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>黑人問號</p></figcaption>\n  </figure></p>\n<p>還是不懂？沒關係，不用害怕，繼續跟我往下走。</p>\n<h2 id=\"範例解析\" style=\"position:relative;\"><a href=\"#%E7%AF%84%E4%BE%8B%E8%A7%A3%E6%9E%90\" aria-label=\"範例解析 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>範例解析</h2>\n<hr>\n<p>綜合過去的觀念，我們一步一步拆解這段程式碼在幹嘛。</p>\n<p>首先，在 JS 執行程式碼之前，它會做兩件事，你還記得嗎？</p>\n<p><strong>Creation</strong>： JS 引擎會創造全域執行環境、 <code class=\"language-text\">window</code> 物件，以及 <code class=\"language-text\">this</code> 變數（代指 <code class=\"language-text\">window</code> 物件）。</p>\n<p><strong>Hoisting</strong>： JS 引擎會將變數宣告與函式宣告儲存進記憶體空間，即創造全域變數與全域函式。在這個例子中，變數 <code class=\"language-text\">fs</code> 會先被創造並賦值為 <code class=\"language-text\">undefined</code> ，而函式 <code class=\"language-text\">buildFunctions()</code> 會被宣告完成。</p>\n<p>接著， JS 引擎才會真正開始執行程式碼。而第一行程式碼是：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">buildFunctions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span></code></pre></div>\n<p>這行程式碼的意思是：</p>\n<blockquote>\n<p>呼叫函式 buildFunctions ，並將執行後 return 的值賦予給變數 fs 。</p>\n</blockquote>\n<p>所以，我們接著要理解函式 <code class=\"language-text\">buildFunctions</code> 到底執行了什麼？</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">buildFunctions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> arr <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>函式 <code class=\"language-text\">buildFunctions</code> 被呼叫後，<strong>JS 引擎會創造屬於它的執行環境</strong>，並開始執行 <code class=\"language-text\">{}</code> 內部的程式碼（也就是函式物件的程式屬性）。</p>\n<p>宣告一個區域變數 <code class=\"language-text\">arr</code> 為一個空陣列 <code class=\"language-text\">[]</code>：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  <span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span></code></pre></div>\n<p>跑一個 <code class=\"language-text\">for</code> 迴圈，若符合條件就執行迴圈內容，反之則結束迴圈：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n<p>在 <code class=\"language-text\">for</code> 迴圈這部分，我們宣告一個區域變數 <code class=\"language-text\">i = 0</code> 當作計數器，若 <code class=\"language-text\">i &lt; 3</code>，就執行 <code class=\"language-text\">for {}</code> 內的程式碼，反之則跳出迴圈。</p>\n<p>每次在 <code class=\"language-text\">for {}</code> 裡面，我們要<strong>創造</strong>一個新的函式 <code class=\"language-text\">function(){console.log(i)})</code> ，並將它 <code class=\"language-text\">push</code> 到變數 <code class=\"language-text\">arr</code> 陣列裡面。</p>\n<p>什麼？你說陣列裡面放函式很怪？忘記我們之前說過：陣列是任何東西的集合，可以存放任何純值或（函式）物件。</p>\n<p>我們將每一次迴圈的步驟拆開看：</p>\n<p>第一次迴圈時， <code class=\"language-text\">i = 0</code> ， <code class=\"language-text\">0 &lt; 3</code> ，符合條件，執行迴圈內容：<strong>創造</strong>函式 <code class=\"language-text\">function(){console.log(i)})</code> 並 <code class=\"language-text\">push</code> 到 <code class=\"language-text\">arr</code> 陣列中，接著 <code class=\"language-text\">i ++</code> 。 </p>\n<p>第二次迴圈時， <code class=\"language-text\">i = 1</code> ， <code class=\"language-text\">1 &lt; 3</code> ，符合條件，執行迴圈內容：<strong>創造</strong>函式 <code class=\"language-text\">function(){console.log(i)})</code> 並 <code class=\"language-text\">push</code> 到 <code class=\"language-text\">arr</code> 陣列中，接著 <code class=\"language-text\">i ++</code> 。 </p>\n<p>第三次迴圈時， <code class=\"language-text\">i = 2</code> ， <code class=\"language-text\">2 &lt; 3</code> ，符合條件，執行迴圈內容：<strong>創造</strong>函式 <code class=\"language-text\">function(){console.log(i)})</code> 並 <code class=\"language-text\">push</code> 到 <code class=\"language-text\">arr</code> 陣列中，接著 <code class=\"language-text\">i ++</code> 。 </p>\n<p>第四次迴圈時， <code class=\"language-text\">i = 3</code> ， <code class=\"language-text\">3 &lt; 3</code> ，不符合條件，跳出迴圈， <code class=\"language-text\">for</code> 迴圈結束。</p>\n<p>此時，區域變數 <code class=\"language-text\">arr</code> 為一個陣列，裡面包括三個函式（物件），而區域變數 <code class=\"language-text\">i = 3</code> 。</p>\n<p>回傳變數 <code class=\"language-text\">arr</code> 陣列：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">  <span class=\"token keyword\">return</span> arr <span class=\"token punctuation\">;</span></code></pre></div>\n<p>至此，函式 <code class=\"language-text\">buildFunctions</code> 執行完畢，<strong>JS 引擎會消滅屬於它執行環境</strong>。</p>\n<p>但是！上篇我們有說，<strong>JS 引擎會保留儲存函式參數與區域變數的記憶體空間</strong>，也就是說，<strong>區域變數 <code class=\"language-text\">arr</code> 和 <code class=\"language-text\">i</code> 仍會存於該函式專屬的記憶體空間，並不會消滅</strong>。</p>\n<p>回到全域執行環境，函式 <code class=\"language-text\">buildFunctions</code> 執行後回傳變數 <code class=\"language-text\">arr</code> 陣列，並賦值給變數 <code class=\"language-text\">fs</code> 。</p>\n<p>因此 <code class=\"language-text\">fs = arr</code> 。（想一想，是傳值？還是<strong>傳參考？</strong>） </p>\n<p>終於來到最後一步：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">fs<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\nfs<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span>\nfs<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">;</span></code></pre></div>\n<p>{% colorquote success %}\n依序呼叫變數 <code class=\"language-text\">fs</code> 裡的三個函式並<strong>執行</strong>。\n{% endcolorquote%}</p>\n<p> <code class=\"language-text\">fs[0]</code> 、 <code class=\"language-text\">fs[1]</code> 、 <code class=\"language-text\">fs[2]</code> 三個函式都指向函式 <code class=\"language-text\">function(){console.log(i)})</code> ，以 <code class=\"language-text\">fs[0]()</code> 為例，JS 執行後，會創造其專屬的執行環境，並開始執行程式：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>JS 引擎知道要執行 <code class=\"language-text\">console.log(i)</code> ，於是開始在函式 <code class=\"language-text\">function(){console.log(i)})</code> 裡面找 <code class=\"language-text\">i</code>，但很顯然，它找不到（因為沒有定義），所以它只好依照<strong>範圍鍊</strong>的規則，向<strong>外部（詞彙）環境</strong>尋找可以取用的 <code class=\"language-text\">i</code> 。</p>\n<p>外部詞彙環境是誰？想一想，我們在哪裡<strong>創造</strong>函式 <code class=\"language-text\">function(){console.log(i)})</code> ？</p>\n<p>沒錯！就是在函式 <code class=\"language-text\">buildFunctions</code> 裡面！</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">buildFunctions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    arr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> arr <span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>所以，JS 引擎會參考外部（詞彙）環境函式 <code class=\"language-text\">buildFunctions</code> 裡的區域變數 <code class=\"language-text\">i</code> 。</p>\n<p>此時 <code class=\"language-text\">i</code> 是多少？ <code class=\"language-text\">i = 3</code> 。</p>\n<p>按此邏輯， <code class=\"language-text\">fs[0]()</code> 、 <code class=\"language-text\">fs[1]()</code> 、 <code class=\"language-text\">fs[2]()</code> 印出的結果當然都會是 <code class=\"language-text\">3</code> 了。</p>\n<h2 id=\"創造函式-vs-執行函式\" style=\"position:relative;\"><a href=\"#%E5%89%B5%E9%80%A0%E5%87%BD%E5%BC%8F-vs-%E5%9F%B7%E8%A1%8C%E5%87%BD%E5%BC%8F\" aria-label=\"創造函式 vs 執行函式 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>創造函式 v.s. 執行函式</h2>\n<hr>\n<p>有些人之所以預期執行結果為 <code class=\"language-text\">0</code> 、 <code class=\"language-text\">1</code> 、 <code class=\"language-text\">2</code> ，那是因為混淆<strong>創造函式</strong>和<strong>執行函式</strong>的時機與差異。</p>\n<p>其實，我認為只要釐清<strong>創造函式</strong>和<strong>執行函式</strong>的時機與差異，閉包的原理就很清晰了。</p>\n<p>在這個例子中，<strong>創造函式</strong> <code class=\"language-text\">function(){console.log(i)})</code> 的時候，就只是<strong>單純創造該函式</strong>而已，並不會將外部環境的變數 <code class=\"language-text\">i</code> 一起存進記憶體。</p>\n<p>等到<strong>執行函式</strong>時， JS 引擎在函式執行環境 <code class=\"language-text\">function(){console.log(i)})</code> 中找不到可用的 <code class=\"language-text\">i</code>（因為它函式內部本身並沒有宣告 <code class=\"language-text\">i</code> 值），所以它會依照範圍鍊，向外部詞彙環境參考可用的值。</p>\n<p><strong>外部詞彙環境</strong>，指的就是，我們在哪裡<strong>創造</strong>函式？或說，函式被我們寫在哪裡？</p>\n<p>綜合 JS 種種的特性，形成了閉包的原理：<strong>利用函式執行環境，創造一個封閉空間，包住可供取用的變數</strong>。而那些在範圍鍊中可供取用的變數，又稱為<strong>自由變數（Free Variable）</strong></p>\n<p>總而言之，分清楚<strong>創造（宣告）函式</strong>與<strong>執行（呼叫）函式</strong>的時機以及差異，有助於理解閉包的原理，因為閉包就是綜合這些概念而來。</p>\n<p>課程中用這張圖來解釋本篇範例的運作原理：</p>\n<p><figure class=\"gatsby-resp-image-figure\" style=\"\">\n    <span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b5a87d0a19d4abd699c10e72d298123c/cdb2b/closure2.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.05555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFA//EABYBAQEBAAAAAAAAAAAAAAAAAAIAAf/aAAwDAQACEAMQAAABuoUFSw3LP//EABsQAQACAgMAAAAAAAAAAAAAAAEAEgIDERMx/9oACAEBAAEFApkN9fNTzrxuAT//xAAXEQEBAQEAAAAAAAAAAAAAAAABAAIR/9oACAEDAQE/AcPJb//EABYRAQEBAAAAAAAAAAAAAAAAAAACEf/aAAgBAgEBPwGmP//EABwQAAIBBQEAAAAAAAAAAAAAAAABERASIzEzYf/aAAgBAQAGPwIeZLw6XUmDR//EABoQAAIDAQEAAAAAAAAAAAAAAAABESExUUH/2gAIAQEAAT8hSs7WesFVqW2TAbX0nospEf/aAAwDAQACAAMAAAAQxO//xAAWEQEBAQAAAAAAAAAAAAAAAAABEQD/2gAIAQMBAT8QBN1G7//EABYRAQEBAAAAAAAAAAAAAAAAABEBAP/aAAgBAgEBPxCE0EN//8QAGxABAQADAQEBAAAAAAAAAAAAAREAITFxQfD/2gAIAQEAAT8QQqk83lwAXEzz3Khs/pNGu/rhKTc7ilttapfLMWBFujP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"函式範例的解釋（圖片源自參考資料 1.）\"\n        title=\"函式範例的解釋（圖片源自參考資料 1.）\"\n        src=\"/static/b5a87d0a19d4abd699c10e72d298123c/80e3c/closure2.jpg\"\n        srcset=\"/static/b5a87d0a19d4abd699c10e72d298123c/80e3c/closure2.jpg 720w,\n/static/b5a87d0a19d4abd699c10e72d298123c/fbd2c/closure2.jpg 1180w,\n/static/b5a87d0a19d4abd699c10e72d298123c/cdb2b/closure2.jpg 1281w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\n    <figcaption class=\"gatsby-resp-image-figcaption\"><p>函式範例的解釋（圖片源自參考資料 1.）</p></figcaption>\n  </figure></p>\n<h2 id=\"結論\" style=\"position:relative;\"><a href=\"#%E7%B5%90%E8%AB%96\" aria-label=\"結論 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>結論</h2>\n<hr>\n<ul>\n<li>分清楚創造函式與執行函式的時機以及差異，有助於理解閉包的原理。</li>\n<li>創造函式時， JS 引擎會創造該函式的記憶體空間，並儲存函式內宣告的變數，並不會將外部環境的自由變數一起存進記憶體（除非以參數傳入）。</li>\n<li>執行函式時， JS 引擎如果在函式執行環境中找不到可取用的值，它會依照範圍鍊向外部詞彙環境參考可用的值，直到找到為止。</li>\n<li>閉包的原理就是：利用函式執行環境，創造一個專屬的封閉空間（記憶體空間），包住可供取用的變數。</li>\n<li>自由變數指的是：函式在範圍鍊中可供取用的變數。</li>\n</ul>\n<h2 id=\"參考資料\" style=\"position:relative;\"><a href=\"#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\" aria-label=\"參考資料 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>參考資料</h2>\n<hr>\n<ol>\n<li>JavaScript 全攻略：克服 JS 奇怪的部分 4-47</li>\n</ol>","excerpt":"這題沒答對，你敢說你懂閉包？","tableOfContents":"<ul>\n<li><a href=\"/weird-JavaScript_32/#%E9%96%89%E5%8C%85%E6%A6%82%E5%BF%B5%E7%9A%84%E7%A8%8B%E5%BC%8F%E7%A2%BC%E7%AF%84%E4%BE%8B\">閉包概念的程式碼範例</a></li>\n<li><a href=\"/weird-JavaScript_32/#%E7%AF%84%E4%BE%8B%E8%A7%A3%E6%9E%90\">範例解析</a></li>\n<li><a href=\"/weird-JavaScript_32/#%E5%89%B5%E9%80%A0%E5%87%BD%E5%BC%8F-vs-%E5%9F%B7%E8%A1%8C%E5%87%BD%E5%BC%8F\">創造函式 v.s. 執行函式</a></li>\n<li><a href=\"/weird-JavaScript_32/#%E7%B5%90%E8%AB%96\">結論</a></li>\n<li><a href=\"/weird-JavaScript_32/#%E5%8F%83%E8%80%83%E8%B3%87%E6%96%99\">參考資料</a></li>\n</ul>","fields":{"slug":"/weird-JavaScript_32/"},"frontmatter":{"title":"Wierd JavaScript - 32：閉包（2）","date":"2019-08-26","update":"0001-01-01","tags":["Wierd JavaScript"],"keywords":["Luffy on the Way","Luffy Chen"],"featuredImage":{"publicURL":"/static/b5a87d0a19d4abd699c10e72d298123c/closure2.JPG"}}}},"pageContext":{"slug":"/weird-JavaScript_32/","series":[{"slug":"/weird-JavaScript_01/","title":"Wierd JavaScript - 01：語法解析、詞彙環境、執行脈絡","num":1},{"slug":"/weird-JavaScript_02/","title":"Wierd JavaScript - 02：Name / Value Pair 與物件","num":2},{"slug":"/weird-JavaScript_03/","title":"Wierd JavaScript - 03：全域環境與全域物件","num":3},{"slug":"/weird-JavaScript_04/","title":"Wierd JavaScript - 04：創造、提升與 undefined","num":4},{"slug":"/weird-JavaScript_05/","title":"Wierd JavaScript - 05：單執行緒、同步執行、非同步回呼","num":5},{"slug":"/weird-JavaScript_06/","title":"Wierd JavaScript - 06：呼叫函式、執行堆疊","num":6},{"slug":"/weird-JavaScript_07/","title":"Wierd JavaScript - 07：變數環境與範圍鍊","num":7},{"slug":"/weird-JavaScript_08/","title":"Wierd JavaScript - 08：作用域、let 與區塊作用域","num":8},{"slug":"/weird-JavaScript_09/","title":"Wierd JavaScript - 09：動態型別","num":9},{"slug":"/weird-JavaScript_10/","title":"Wierd JavaScript - 10：基本型別（純值）與物件型別","num":10},{"slug":"/weird-JavaScript_11/","title":"Wierd JavaScript - 11：運算子","num":11},{"slug":"/weird-JavaScript_12/","title":"Wierd JavaScript - 12：運算子的優先性與相依性","num":12},{"slug":"/weird-JavaScript_13/","title":"Wierd JavaScript - 13：強制型轉","num":13},{"slug":"/weird-JavaScript_14/","title":"Wierd JavaScript - 14：存在與布林、條件判斷與預設值","num":14},{"slug":"/weird-JavaScript_15/","title":"Wierd JavaScript - 15：創造物件、物件實字","num":15},{"slug":"/weird-JavaScript_16/","title":"Wierd JavaScript - 16：物件的屬性、方法以及取用","num":16},{"slug":"/weird-JavaScript_17/","title":"Wierd JavaScript - 17：偽裝命名空間","num":17},{"slug":"/weird-JavaScript_18/","title":"Wierd JavaScript - 18：JSON v.s. 物件","num":18},{"slug":"/weird-JavaScript_19/","title":"Wierd JavaScript - 19：一級函式","num":19},{"slug":"/weird-JavaScript_20/","title":"Wierd JavaScript - 20：函式陳述式與函式表達式","num":20},{"slug":"/weird-JavaScript_21/","title":"Wierd JavaScript - 21：傳值 v.s. 傳參考","num":21},{"slug":"/weird-JavaScript_22/","title":"Wierd JavaScript - 22：What's this ?","num":22},{"slug":"/weird-JavaScript_23/","title":"Wierd JavaScript - 23：陣列","num":23},{"slug":"/weird-JavaScript_24/","title":"Wierd JavaScript - 24：參數（parameter v.s. arguments）","num":24},{"slug":"/weird-JavaScript_25/","title":"Wierd JavaScript - 25：重載函式","num":25},{"slug":"/weird-JavaScript_26/","title":"Wierd JavaScript - 26：語法解析器","num":26},{"slug":"/weird-JavaScript_27/","title":"Wierd JavaScript - 27：自動插入分號","num":27},{"slug":"/weird-JavaScript_28/","title":"Wierd JavaScript - 28：空格","num":28},{"slug":"/weird-JavaScript_29/","title":"Wierd JavaScript - 29：立即呼叫函式表達式（IIFEs）","num":29},{"slug":"/weird-JavaScript_30/","title":"Wierd JavaScript - 30：IIFEs 與安全程式碼","num":30},{"slug":"/weird-JavaScript_31/","title":"Wierd JavaScript - 31：閉包（1）","num":31},{"slug":"/weird-JavaScript_32/","title":"Wierd JavaScript - 32：閉包（2）","num":32},{"slug":"/weird-JavaScript_33/","title":"Wierd JavaScript - 33：函式工廠","num":33},{"slug":"/weird-JavaScript_34/","title":"Wierd JavaScript - 34：閉包與回呼","num":34},{"slug":"/weird-JavaScript_35/","title":"Wierd JavaScript - 35：call()、apply()、bind()","num":35},{"slug":"/weird-JavaScript_36/","title":"Wierd JavaScript - 36：函式程式設計（一）","num":36},{"slug":"/weird-JavaScript_37/","title":"Wierd JavaScript - 37：函式程式設計（二）","num":37},{"slug":"/weird-JavaScript_38/","title":"Wierd JavaScript - 38：古典繼承 v.s. 原型繼承","num":38},{"slug":"/weird-JavaScript_39/","title":"Wierd JavaScript - 39：原型與原型鍊","num":39},{"slug":"/weird-JavaScript_40/","title":"Wierd JavaScript - 40：所有東西都是物件（或純值）","num":40}],"lastmod":"2019-08-26"}},"staticQueryHashes":["2027115977"]}